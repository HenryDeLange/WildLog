package wildlog.ui.dialogs;

import java.awt.Cursor;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.swing.DefaultComboBoxModel;
import javax.swing.ImageIcon;
import javax.swing.JDialog;
import javax.swing.JOptionPane;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;
import org.apache.logging.log4j.Level;
import wildlog.WildLogApp;
import wildlog.data.dataobjects.Element;
import wildlog.data.dataobjects.Location;
import wildlog.data.dataobjects.Sighting;
import wildlog.data.dataobjects.Visit;
import wildlog.data.dataobjects.WildLogFile;
import wildlog.data.dataobjects.wrappers.SightingWrapper;
import wildlog.data.dbi.WildLogDBI;
import wildlog.data.dbi.WildLogDBI_h2;
import wildlog.data.enums.system.WildLogFileType;
import wildlog.data.enums.system.WildLogThumbnailSizes;
import wildlog.ui.dialogs.utils.UtilsDialog;
import wildlog.ui.helpers.ComboBoxFixer;
import wildlog.ui.helpers.ProgressbarTask;
import wildlog.ui.helpers.WLOptionPane;
import wildlog.ui.helpers.renderers.WorkspaceTreeCellRenderer;
import wildlog.ui.helpers.renderers.WorkspaceTreeDataWrapper;
import wildlog.utils.UtilsConcurency;
import wildlog.utils.UtilsFileProcessing;
import wildlog.utils.UtilsImageProcessing;
import wildlog.utils.WildLogPaths;


public class WorkspaceImportDialog extends JDialog {
    private Path importWorkspace;
    private WildLogDBI importDBI = null;
    private int importLocationTotal = 0;
    private int importVisitTotal = 0;
    private int importElementTotal = 0;
    private int importSightingTotal = 0;
    private int importFileTotal = 0;
    private int importLocationConflicts = 0;
    private int importVisitConflicts = 0;
    private int importElementConflicts = 0;
    private int importSightingConflicts = 0;
    private int importFileConflicts = 0;


    public WorkspaceImportDialog(Path inImportPath) {
        super();
        WildLogApp.LOGGER.log(Level.INFO, "[WorkspaceImportDialog]");
        importWorkspace = inImportPath;
        try {
        importDBI = new WildLogDBI_h2((importWorkspace.resolve(WildLogPaths.WILDLOG_DATA.getRelativePath()).resolve(
                WildLogPaths.DEFAULT_DATABASE_NAME.getRelativePath())).toAbsolutePath().toString(), false, false);
        }
        catch (Exception ex) {
            WildLogApp.LOGGER.log(Level.ERROR, ex.toString(), ex);
        }
        initComponents();
        ComboBoxFixer.configureComboBoxes(cmbThumbnailSize);
        // Setup the tree
        treWorkspace.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        treWorkspace.setCellRenderer(new WorkspaceTreeCellRenderer());
        treWorkspace.setToggleClickCount(0);
        // Load the tree
        loadLocationTree();
        // Setup the default behavior
        UtilsDialog.setDialogToCenter(WildLogApp.getApplication().getMainFrame(), this);
        UtilsDialog.addEscapeKeyListener(this);
        // Setup the glasspane on this dialog as well for the JOptionPane's
        UtilsDialog.addModalBackgroundPanel(WildLogApp.getApplication().getMainFrame(), this);
        UtilsDialog.addModalBackgroundPanel(this, null);
    }

    /**
     * Empty contructor. To be used by the CSV import that wants access to the shared import methods.
     */
    public WorkspaceImportDialog() {
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        grpFiles = new javax.swing.ButtonGroup();
        grpImages = new javax.swing.ButtonGroup();
        grpTreeOrder = new javax.swing.ButtonGroup();
        grpConflicts = new javax.swing.ButtonGroup();
        btnConfirm = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        treWorkspace = new javax.swing.JTree();
        jLabel2 = new javax.swing.JLabel();
        rdbImportAllFiles = new javax.swing.JRadioButton();
        rdbImportImagesOnly = new javax.swing.JRadioButton();
        rdbImportNoFiles = new javax.swing.JRadioButton();
        jSeparator1 = new javax.swing.JSeparator();
        rdbImportOriginalImages = new javax.swing.JRadioButton();
        rdbImportThumbnails = new javax.swing.JRadioButton();
        jLabel1 = new javax.swing.JLabel();
        rdbOrderByLocation = new javax.swing.JRadioButton();
        rdbOrderByElement = new javax.swing.JRadioButton();
        jLabel3 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        rdbConflictAutoResolve = new javax.swing.JRadioButton();
        rdbConflictAsk = new javax.swing.JRadioButton();
        jSeparator2 = new javax.swing.JSeparator();
        jSeparator3 = new javax.swing.JSeparator();
        btnCheckConflicts = new javax.swing.JButton();
        cmbThumbnailSize = new javax.swing.JComboBox<>();
        jLabel7 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Import From An External Workspace");
        setIconImage(new ImageIcon(WildLogApp.class.getResource("resources/icons/WildLog Icon Small.gif")).getImage());
        setMinimumSize(new java.awt.Dimension(850, 700));
        setModal(true);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosed(java.awt.event.WindowEvent evt) {
                formWindowClosed(evt);
            }
        });

        btnConfirm.setIcon(new javax.swing.ImageIcon(getClass().getResource("/wildlog/resources/icons/Update.png"))); // NOI18N
        btnConfirm.setToolTipText("Import the selected records to the active Workspace.");
        btnConfirm.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnConfirm.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnConfirmActionPerformed(evt);
            }
        });

        javax.swing.tree.DefaultMutableTreeNode treeNode1 = new javax.swing.tree.DefaultMutableTreeNode("root");
        treWorkspace.setModel(new javax.swing.tree.DefaultTreeModel(treeNode1));
        treWorkspace.setRequestFocusEnabled(false);
        treWorkspace.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                treWorkspaceMousePressed(evt);
            }
        });
        jScrollPane1.setViewportView(treWorkspace);

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel2.setText("Files:");

        grpFiles.add(rdbImportAllFiles);
        rdbImportAllFiles.setSelected(true);
        rdbImportAllFiles.setText("All Files");
        rdbImportAllFiles.setToolTipText("Import all files into the current Workspace.");
        rdbImportAllFiles.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportAllFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportAllFilesActionPerformed(evt);
            }
        });

        grpFiles.add(rdbImportImagesOnly);
        rdbImportImagesOnly.setText("Images Only");
        rdbImportImagesOnly.setToolTipText("Import only image files into the current Workspace.");
        rdbImportImagesOnly.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportImagesOnly.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportImagesOnlyActionPerformed(evt);
            }
        });

        grpFiles.add(rdbImportNoFiles);
        rdbImportNoFiles.setText("No Files");
        rdbImportNoFiles.setToolTipText("Don't import any files into the current Workspace.");
        rdbImportNoFiles.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportNoFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportNoFilesActionPerformed(evt);
            }
        });

        jSeparator1.setOrientation(javax.swing.SwingConstants.VERTICAL);

        grpImages.add(rdbImportOriginalImages);
        rdbImportOriginalImages.setSelected(true);
        rdbImportOriginalImages.setText("Original Images");
        rdbImportOriginalImages.setToolTipText("Import a copy of the original linked images into the current Workspace.");
        rdbImportOriginalImages.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportOriginalImages.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportOriginalImagesActionPerformed(evt);
            }
        });

        grpImages.add(rdbImportThumbnails);
        rdbImportThumbnails.setText("Thumbnail Images");
        rdbImportThumbnails.setToolTipText("The images that are imported will be reduced in size, the original images will not be imported.");
        rdbImportThumbnails.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportThumbnails.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportThumbnailsActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel1.setText("Sort Order:");

        grpTreeOrder.add(rdbOrderByLocation);
        rdbOrderByLocation.setSelected(true);
        rdbOrderByLocation.setText("Order by Place");
        rdbOrderByLocation.setToolTipText("Order the tree nodes by Places, then Periods and lastly Creatures.");
        rdbOrderByLocation.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbOrderByLocation.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbOrderByLocationActionPerformed(evt);
            }
        });

        grpTreeOrder.add(rdbOrderByElement);
        rdbOrderByElement.setText("Order by Creature");
        rdbOrderByElement.setToolTipText("Order the tree nodes by Creatures, then Places and lastly Periods.");
        rdbOrderByElement.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbOrderByElement.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbOrderByElementActionPerformed(evt);
            }
        });

        jLabel3.setText("<html><i>The records marked with the WildLog (W) icon will be imported. Hold down the Ctrl key to select only the record, without it's sub-records.</i></html>");

        jLabel5.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel5.setText("Conflicts:");

        grpConflicts.add(rdbConflictAutoResolve);
        rdbConflictAutoResolve.setSelected(true);
        rdbConflictAutoResolve.setText("Automatically choose the most recently edited record and largest file");
        rdbConflictAutoResolve.setToolTipText("<html>When the active Workspace and the imported Workspace contains records with the same IDs but different data fields then the most recently edited record will automatically be used in the active Workspace.</html>");
        rdbConflictAutoResolve.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));

        grpConflicts.add(rdbConflictAsk);
        rdbConflictAsk.setText("Ask what to do for each conflict");
        rdbConflictAsk.setToolTipText("<html>When the active Workspace and the imported Workspace contains records with the same IDs but different data fields then the user will be asked which record to use in the active Workspace.</html>");
        rdbConflictAsk.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));

        btnCheckConflicts.setText("<html>Check for Conflicts</html>");
        btnCheckConflicts.setToolTipText("Checks how many conflicts there will be when importing using the selected records.");
        btnCheckConflicts.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnCheckConflicts.setMargin(new java.awt.Insets(2, 2, 2, 2));
        btnCheckConflicts.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCheckConflictsActionPerformed(evt);
            }
        });

        cmbThumbnailSize.setMaximumRowCount(15);
        cmbThumbnailSize.setModel(new DefaultComboBoxModel(WildLogThumbnailSizes.values()));
        cmbThumbnailSize.setSelectedItem(WildLogThumbnailSizes.VERY_LARGE);
        cmbThumbnailSize.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        cmbThumbnailSize.setEnabled(false);

        jLabel7.setText("px");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addGap(10, 10, 10)
                                .addComponent(rdbImportAllFiles)
                                .addGap(5, 5, 5)
                                .addComponent(rdbImportImagesOnly)
                                .addGap(5, 5, 5)
                                .addComponent(rdbImportNoFiles)
                                .addGap(10, 10, 10)
                                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(10, 10, 10)
                                .addComponent(rdbImportOriginalImages)
                                .addGap(5, 5, 5)
                                .addComponent(rdbImportThumbnails)
                                .addGap(5, 5, 5)
                                .addComponent(cmbThumbnailSize, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(5, 5, 5)
                                .addComponent(jLabel7)
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel5)
                                        .addGap(10, 10, 10)
                                        .addComponent(rdbConflictAutoResolve)
                                        .addGap(5, 5, 5)
                                        .addComponent(rdbConflictAsk))
                                    .addComponent(jSeparator2))
                                .addGap(5, 5, 5))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jSeparator3)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(1, 1, 1)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel1)
                                        .addGap(10, 10, 10)
                                        .addComponent(rdbOrderByLocation)
                                        .addGap(5, 5, 5)
                                        .addComponent(rdbOrderByElement)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 80, Short.MAX_VALUE)))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(btnConfirm, javax.swing.GroupLayout.PREFERRED_SIZE, 110, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(btnCheckConflicts, javax.swing.GroupLayout.PREFERRED_SIZE, 110, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addGap(5, 5, 5))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jSeparator1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jLabel7)
                                    .addComponent(cmbThumbnailSize, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(rdbImportOriginalImages)
                                    .addComponent(rdbImportThumbnails)
                                    .addComponent(rdbImportImagesOnly)
                                    .addComponent(rdbImportAllFiles)
                                    .addComponent(rdbImportNoFiles))))
                        .addGap(5, 5, 5)
                        .addComponent(jSeparator3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(5, 5, 5)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(rdbConflictAutoResolve, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(rdbConflictAsk, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(5, 5, 5)
                        .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(5, 5, 5)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(rdbOrderByLocation)
                            .addComponent(rdbOrderByElement))
                        .addGap(5, 5, 5)
                        .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(btnConfirm, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(5, 5, 5)
                        .addComponent(btnCheckConflicts, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(2, 2, 2)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 565, Short.MAX_VALUE)
                .addGap(5, 5, 5))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnConfirmActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnConfirmActionPerformed
        try {
            if (importWorkspace != null) {
                UtilsConcurency.kickoffProgressbarTask(WildLogApp.getApplication(), new ProgressbarTask(WildLogApp.getApplication()) {
                    @Override
                    protected Object doInBackground() throws Exception {
                        WildLogApp.getApplication().getMainFrame().getGlassPane().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
                        setProgress(1);
                        setMessage("Starting the Workspace Import");
                        setVisible(false);
                        try {
                            int totalSelectedNodes = getNumberOfSelectedNodes(treWorkspace.getModel(), (DefaultMutableTreeNode) treWorkspace.getModel().getRoot());
                            if (totalSelectedNodes > 0) {
                                Path feedbackFile = WildLogPaths.getFullWorkspacePrefix().resolve("WorkspaceImportReport.txt");
                                PrintWriter feedback = null;
                                try {
                                    feedback = new PrintWriter(new FileWriter(feedbackFile.toFile()), true);
                                    feedback.println("---------------------------------------------");
                                    feedback.println("---------- Workspace Import Report ----------");
                                    feedback.println("---------------------------------------------");
                                    feedback.println("");
                                    setProgress(2);
                                    setMessage("Workspace Import: " + getProgress() + "%");
                                    // Only process Elements, Locations and Visits once (can be multiple times in the tree)
                                    Set<String> processedData = new HashSet<>();
                                    // Start processing
                                    importRecords((DefaultMutableTreeNode) treWorkspace.getModel().getRoot(), totalSelectedNodes, this, new ProgressCounter(), processedData, feedback);
                                    // Write summary
                                    writeImportSummary(feedback);
                                    setProgress(100);
                                    setMessage("Workspace Import: " + getProgress() + "%");
                                }
                                catch (Exception ex) {
                                    if (feedback != null) {
                                        feedback.println("");
                                        feedback.println("--------------------------------------");
                                        feedback.println("--------------- ERROR ----------------");
                                        feedback.println(ex.toString());
                                        feedback.println("--------------------------------------");
                                        feedback.println("");
                                    }
                                    throw ex;
                                }
                                finally {
                                    if (feedback != null) {
                                        feedback.println("");
                                        feedback.println("--------------------------------------");
                                        feedback.println("-------------- FINISHED --------------");
                                        feedback.println("--------------------------------------");
                                        feedback.println("");
                                        feedback.flush();
                                        feedback.close();
                                        // Open the summary document
                                        UtilsFileProcessing.openFile(feedbackFile);
                                    }
                                }
                            }
                        }
                        catch (Exception ex) {
                            throw ex;
                        }
                        finally {
                            WildLogApp.getApplication().getMainFrame().refreshHomeTab();
                            setVisible(false);
                            dispose();
                            if (importDBI != null) {
                                importDBI.close();
                            }
                        }
                        setProgress(100);
                        setMessage("Done with the Workspace Import");
                        WildLogApp.getApplication().getMainFrame().getGlassPane().setCursor(Cursor.getDefaultCursor());
                        return null;
                    }
                });
            }
        }
        catch (Exception ex) {
            WildLogApp.LOGGER.log(Level.ERROR, ex.toString(), ex);
            WLOptionPane.showMessageDialog(WildLogApp.getApplication().getMainFrame(),
                    "Could not import the Workspace successfully.",
                    "Import Workspace Error", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_btnConfirmActionPerformed

    private class ProgressCounter {
        public int counter = 0;
    }

    private int getNumberOfSelectedNodes(TreeModel inModel, DefaultMutableTreeNode inNode) {
        int count = 0;
        if (inNode.getUserObject() instanceof WorkspaceTreeDataWrapper) {
            WorkspaceTreeDataWrapper dataWrapper = (WorkspaceTreeDataWrapper) inNode.getUserObject();
            if (dataWrapper.isSelected()) {
                count = 1;
            }
        }
        int numberOfChildren = inModel.getChildCount(inNode);
        for (int i = 0; i < numberOfChildren; i++) {
            count += getNumberOfSelectedNodes(inModel, (DefaultMutableTreeNode) inModel.getChild(inNode, i));
        }
        return count;
    }

    private void importRecords(DefaultMutableTreeNode inNode, int inTotalNodes, ProgressbarTask inProgressbarTask, ProgressCounter inCounter, 
            Set<String> inProcessedData, PrintWriter inFeedback) {
        if (inNode.getUserObject() instanceof WorkspaceTreeDataWrapper) {
            WorkspaceTreeDataWrapper dataWrapper = (WorkspaceTreeDataWrapper) inNode.getUserObject();
            if (dataWrapper.isSelected()) {
                if (dataWrapper.getDataObject() instanceof Location) {
                    if (inProcessedData.add("L" + ((Location) dataWrapper.getDataObject()).getID())) {
                        Location importLocation = importDBI.findLocation(((Location) dataWrapper.getDataObject()).getID(), null, false, Location.class);
                        importLocationRecord(importLocation, rdbConflictAutoResolve.isSelected(), inFeedback);
                        saveFiles(importLocation.getWildLogFileID(), inFeedback);
                    }
                }
                else
                if (dataWrapper.getDataObject() instanceof Visit) {
                    if (inProcessedData.add("V" + ((Visit) dataWrapper.getDataObject()).getID())) {
                        Visit importVisit = importDBI.findVisit(((Visit) dataWrapper.getDataObject()).getID(), null, true, Visit.class);
                        importVisitRecord(importVisit, rdbConflictAutoResolve.isSelected(), inFeedback);
                        saveFiles(importVisit.getWildLogFileID(), inFeedback);
                    }
                }
                else
                if (dataWrapper.getDataObject() instanceof Element) {
                    if (inProcessedData.add("E" + ((Element) dataWrapper.getDataObject()).getID())) {
                        Element importElement = importDBI.findElement(((Element) dataWrapper.getDataObject()).getID(), null, false, Element.class);
                        importElementRecord(importElement, rdbConflictAutoResolve.isSelected(), inFeedback);
                        saveFiles(importElement.getWildLogFileID(), inFeedback);
                    }
                }
                else
                if (dataWrapper.getDataObject() instanceof SightingWrapper) {
                    Sighting importSighting = importDBI.findSighting((((SightingWrapper) dataWrapper.getDataObject()).getSighting()).getID(), true, Sighting.class);
                    importSightingRecord(importSighting, rdbConflictAutoResolve.isSelected(), inFeedback);
                    saveFiles(importSighting.getWildLogFileID(), inFeedback);
                }
                inCounter.counter++;
            }
            inProgressbarTask.setTaskProgress(2 + (int)(inCounter.counter/(double)inTotalNodes*97));
            inProgressbarTask.setMessage("Workspace Import: " + inProgressbarTask.getProgress() + "%");
        }
        for (int t = 0; t < treWorkspace.getModel().getChildCount(inNode); t++) {
            DefaultMutableTreeNode childNode = (DefaultMutableTreeNode) treWorkspace.getModel().getChild(inNode, t);
            importRecords(childNode, inTotalNodes, inProgressbarTask, inCounter, inProcessedData, inFeedback);
        }
    }

    public void importLocationRecord(Location inImportLocation, boolean inAutoResolve, PrintWriter inFeedback) {
        // Check to make sure the name of the importing records is unique in the active workspace
        Location checkWorkspaceName = WildLogApp.getApplication().getDBI().findLocation(0, inImportLocation.getName(), false, Location.class);
        while (checkWorkspaceName != null && checkWorkspaceName.getID() != inImportLocation.getID()) {
            inImportLocation.setName("wlimport_" + inImportLocation.getName());
            checkWorkspaceName = WildLogApp.getApplication().getDBI().findLocation(0, inImportLocation.getName(), false, Location.class);
        }
        // Save the new record
        Location workspaceLocation = WildLogApp.getApplication().getDBI().findLocation(inImportLocation.getID(), null, false, Location.class);
        if (workspaceLocation == null) {
            // New
            WildLogApp.getApplication().getDBI().createLocation(inImportLocation, true);
            importLocationTotal++;
            inFeedback.println("Imported Place: " + inImportLocation.getDisplayName() + " [" + inImportLocation.getID() + "]");
        }
        else {
            // Update
            if (!inImportLocation.hasTheSameContent(workspaceLocation)) {
                importLocationConflicts++;
                if (inAutoResolve) {
                    if (inImportLocation.getAuditTime() > workspaceLocation.getAuditTime()) {
                        WildLogApp.getApplication().getDBI().updateLocation(inImportLocation, inImportLocation.getName(), true);
                        importLocationTotal++;
                        inFeedback.println("Auto Updated Place: " + inImportLocation.getDisplayName() + " [" + inImportLocation.getID() + "]");
                    }
                }
                else {
                    WorkspaceImportConflictDialog dialog = new WorkspaceImportConflictDialog(inImportLocation, workspaceLocation);
                    dialog.setVisible(true);
                    if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.IMPORT) {
                        WildLogApp.getApplication().getDBI().updateLocation(inImportLocation, inImportLocation.getName(), true);
                        importLocationTotal++;
                        inFeedback.println("Manual Updated Place: " + inImportLocation.getDisplayName() + " [" + inImportLocation.getID() + "]");
                    }
                    else
                    if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.WORKSPACE) {
                        inFeedback.println("Keep Workspace Place: " + workspaceLocation.getDisplayName() + " [" + workspaceLocation.getID() + "]");
                    }
                    else {
                        // Left unresolved, so we fall back to skipping the record
                        inFeedback.println("Skipped Place: " + workspaceLocation.getDisplayName() + " [" + workspaceLocation.getID() + "]");
                    }
                }
            }
        }
    }
    
    public void importVisitRecord(Visit inImportVisit, boolean inAutoResolve, PrintWriter inFeedback) {
        // Check to make sure the name of the importing records is unique in the active workspace
        Visit checkWorkspaceName = WildLogApp.getApplication().getDBI().findVisit(0, inImportVisit.getName(), false, Visit.class);
        while (checkWorkspaceName != null && checkWorkspaceName.getID() != inImportVisit.getID()) {
            inImportVisit.setName("wlimport_" + inImportVisit.getName());
            checkWorkspaceName = WildLogApp.getApplication().getDBI().findVisit(0, inImportVisit.getName(), false, Visit.class);
        }
        // Save the new record
        Visit workspaceVisit = WildLogApp.getApplication().getDBI().findVisit(inImportVisit.getID(), null, true, Visit.class);
        if (workspaceVisit == null) {
            // New
            WildLogApp.getApplication().getDBI().createVisit(inImportVisit, true);
            importVisitTotal++;
            inFeedback.println("Imported Period: " + inImportVisit.getDisplayName() + " [" + inImportVisit.getID() + "]");
        }
        else {
            // Update
            if (!inImportVisit.hasTheSameContent(workspaceVisit)) {
                importVisitConflicts++;
                if (inAutoResolve) {
                    if (inImportVisit.getAuditTime() > workspaceVisit.getAuditTime()) {
                        WildLogApp.getApplication().getDBI().updateVisit(inImportVisit, inImportVisit.getName(), true);
                        importVisitTotal++;
                        inFeedback.println("Auto Updated Period: " + inImportVisit.getDisplayName() + " [" + inImportVisit.getID() + "]");
                    }
                }
                else {
                    WorkspaceImportConflictDialog dialog = new WorkspaceImportConflictDialog(inImportVisit, workspaceVisit);
                    dialog.setVisible(true);
                    if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.IMPORT) {
                        WildLogApp.getApplication().getDBI().updateVisit(inImportVisit, inImportVisit.getName(), true);
                        importVisitTotal++;
                        inFeedback.println("Manual Updated Period: " + inImportVisit.getDisplayName() + " [" + inImportVisit.getID() + "]");
                    }
                    else
                    if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.WORKSPACE) {
                        inFeedback.println("Keep Workspace Period: " + workspaceVisit.getDisplayName() + " [" + workspaceVisit.getID() + "]");
                    }
                    else {
                        // Left unresolved, so we fall back to skipping the record
                        inFeedback.println("Skipped Period: " + workspaceVisit.getDisplayName() + " [" + workspaceVisit.getID() + "]");
                    }
                }
            }
        }
    }
    
    public void importElementRecord(Element inImportElement, boolean inAutoResolve, PrintWriter inFeedback) {
        // Check to make sure the name of the importing records is unique in the active workspace
        Element checkWorkspaceName = WildLogApp.getApplication().getDBI().findElement(0, inImportElement.getPrimaryName(), false, Element.class);
        while (checkWorkspaceName != null && checkWorkspaceName.getID() != inImportElement.getID()) {
            inImportElement.setPrimaryName("wlimport_" + inImportElement.getPrimaryName());
            checkWorkspaceName = WildLogApp.getApplication().getDBI().findElement(0, inImportElement.getPrimaryName(), false, Element.class);
        }
        // Save the new record
        Element workspaceElement = WildLogApp.getApplication().getDBI().findElement(inImportElement.getID(), null, false, Element.class);
        if (workspaceElement == null) {
            // New
            WildLogApp.getApplication().getDBI().createElement(inImportElement, true);
            importElementTotal++;
            inFeedback.println("Imported Creature: " + inImportElement.getDisplayName() + " [" + inImportElement.getID() + "]");
        }
        else {
            // Update
            if (!inImportElement.hasTheSameContent(workspaceElement)) {
                importElementConflicts++;
                if (inAutoResolve) {
                    if (inImportElement.getAuditTime() > workspaceElement.getAuditTime()) {
                        WildLogApp.getApplication().getDBI().updateElement(inImportElement, inImportElement.getPrimaryName(), true);
                        importElementTotal++;
                        inFeedback.println("Auto Updated Creature: " + inImportElement.getDisplayName() + " [" + inImportElement.getID() + "]");
                    }
                }
                else {
                    WorkspaceImportConflictDialog dialog = new WorkspaceImportConflictDialog(inImportElement, workspaceElement);
                    dialog.setVisible(true);
                    if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.IMPORT) {
                        WildLogApp.getApplication().getDBI().updateElement(inImportElement, inImportElement.getPrimaryName(), true);
                        importElementTotal++;
                        inFeedback.println("Manual Updated Creature: " + inImportElement.getDisplayName() + " [" + inImportElement.getID() + "]");
                    }
                    else
                    if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.WORKSPACE) {
                        inFeedback.println("Keep Workspace Creature: " + workspaceElement.getDisplayName() + " [" + workspaceElement.getID() + "]");
                    }
                    else {
                        // Left unresolved, so we fall back to skipping the record
                        inFeedback.println("Skipped Creature: " + workspaceElement.getDisplayName() + " [" + workspaceElement.getID() + "]");
                    }
                }
            }
        }
    }
    
    public void importSightingRecord(Sighting importSighting, boolean inAutoResolve, PrintWriter inFeedback) {
        // Save the new record
        Sighting workpaceSighting = WildLogApp.getApplication().getDBI().findSighting(importSighting.getID(), true, Sighting.class);
        if (workpaceSighting == null) {
            // New
            WildLogApp.getApplication().getDBI().createSighting(importSighting, true);
            importSightingTotal++;
            inFeedback.println("Imported Observation: " + importSighting.getDisplayName() + " [" + importSighting.getID() + "]");
        }
        else {
            // Update
            if (!importSighting.hasTheSameContent(workpaceSighting)) {
                importSightingConflicts++;
                if (inAutoResolve) {
                    if (importSighting.getAuditTime() > workpaceSighting.getAuditTime()) {
                        WildLogApp.getApplication().getDBI().updateSighting(importSighting, true);
                        importSightingTotal++;
                        inFeedback.println("Auto Updated Observation: " + importSighting.getDisplayName() + " [" + importSighting.getID() + "]");
                    }
                }
                else {
                    WorkspaceImportConflictDialog dialog = new WorkspaceImportConflictDialog(importSighting, workpaceSighting);
                    dialog.setVisible(true);
                    if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.IMPORT) {
                        WildLogApp.getApplication().getDBI().updateSighting(importSighting, true);
                        importSightingTotal++;
                        inFeedback.println("Manual Updated Observation: " + importSighting.getDisplayName() + " [" + importSighting.getID() + "]");
                    }
                    else
                    if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.WORKSPACE) {
                        inFeedback.println("Keep Workspace Observation: " + workpaceSighting.getDisplayName() + " [" + workpaceSighting.getID() + "]");
                    }
                    else {
                        // Left unresolved, so we fall back to skipping the record
                        inFeedback.println("Skipped Observation: " + workpaceSighting.getDisplayName() + " [" + workpaceSighting.getID() + "]");
                    }
                }
            }
        }
    }
    
    public void writeImportSummary(PrintWriter feedback) {
        int importTotal = importLocationTotal + importVisitTotal + importElementTotal + importSightingTotal + importFileTotal;
        int importConflicts = importLocationConflicts + importVisitConflicts + importElementConflicts + importSightingConflicts + importFileConflicts;
        WildLogApp.LOGGER.log(Level.INFO, "Imported {} records successfully, of which {} were conflicts.", importTotal, importConflicts);
        feedback.println("");
        feedback.println("-------------- SUMMARY --------------");
        feedback.println("TOTAL IMPORTED RECORDS      : " + importTotal);
        feedback.println("TOTAL CONFLICTS             : " + importConflicts);
        feedback.println("");
        feedback.println("Places imported             : " + importLocationTotal);
        feedback.println("Places conflicted           : " + importLocationConflicts);
        feedback.println("Periods imported            : " + importVisitTotal);
        feedback.println("Periods conflicted          : " + importVisitConflicts);
        feedback.println("Creatures imported          : " + importElementTotal);
        feedback.println("Creatures conflicted        : " + importElementConflicts);
        feedback.println("Observations imported       : " + importSightingTotal);
        feedback.println("Observations conflicted     : " + importSightingConflicts);
        feedback.println("Files imported              : " + importFileTotal);
        feedback.println("Files conflicted            : " + importFileConflicts);
    }

    private void saveFiles(long inWildLogFileID, PrintWriter inFeedback) {
        // Note: Ek kan WildLogFile.getAbsolutePath() op die import file roep want dit sal relative tot die huidige active workspace wees.
        if (!rdbImportNoFiles.isSelected()) {
            WildLogFileType fileType = null;
            if (rdbImportImagesOnly.isSelected()) {
                fileType = WildLogFileType.IMAGE;
            }
            List<WildLogFile> listExternalFiles = importDBI.listWildLogFiles(inWildLogFileID, fileType, WildLogFile.class);
            for (WildLogFile fileToImport : listExternalFiles) {
                if (WildLogApp.getApplication().getDBI().countWildLogFiles(fileToImport.getID(), 0) == 0) {
                    // Die file bestaan nie in die workspace nie, kan dus nuut geskep/gecopy word
                    // Don't overwrite existing files
                    if (Files.exists(fileToImport.getAbsolutePath())) {
                        // There is already a file on the disk with the same path, thus we need to rename this one
                        while (Files.exists(fileToImport.getAbsolutePath())) {
                            fileToImport.setDBFilePath(fileToImport.getRelativePath().getParent().resolve("wlimport_" + fileToImport.getRelativePath().getFileName()).toString());
                            WildLogApp.LOGGER.log(Level.INFO, "Renaming importing file to: " + fileToImport.getAbsolutePath().toString());
                        }
                    }
                    // Copy file
                    copyFile(fileToImport);
                    // Save DB entry
                    WildLogApp.getApplication().getDBI().createWildLogFile(fileToImport, true);
                    importFileTotal++;
                    inFeedback.println("Imported File: " + fileToImport.getDBFilePath() + " [" + fileToImport.getID() + "]");
                }
                else {
                    try {
                        Path fileToImportFullPath = importWorkspace.resolve(fileToImport.getRelativePath()).toAbsolutePath();
                        // This file is already in the current workspace
                        WildLogFile workpaceFile = WildLogApp.getApplication().getDBI().findWildLogFile(fileToImport.getID(), 0, null, null, WildLogFile.class);
                        if (rdbConflictAutoResolve.isSelected()) {
                            if (Files.size(fileToImportFullPath) != Files.size(workpaceFile.getAbsolutePath())) {
                                importFileConflicts++;
                            }
                            if (Files.size(fileToImportFullPath) > Files.size(workpaceFile.getAbsolutePath())) {
                                // Copy file
                                copyFile(fileToImport);
                                // Save DB entry
                                WildLogApp.getApplication().getDBI().updateWildLogFile(fileToImport, true);
                                importFileTotal++;
                                inFeedback.println("Auto Updated File: " + fileToImport.getDBFilePath() + " [" + fileToImport.getID() + "]");
                            }
                        }
                        else {
                            if (Files.size(fileToImportFullPath) != Files.size(workpaceFile.getAbsolutePath())) {
                                importFileConflicts++;
                                WorkspaceImportConflictDialog dialog = new WorkspaceImportConflictDialog(fileToImportFullPath, workpaceFile.getAbsolutePath());
                                dialog.setVisible(true);
                                if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.IMPORT) {
                                    // Copy file
                                    copyFile(fileToImport);
                                    // Save DB entry
                                    WildLogApp.getApplication().getDBI().updateWildLogFile(fileToImport, true);
                                    importFileTotal++;
                                    inFeedback.println("Manual Updated File: " + fileToImport.getDBFilePath() + " [" + fileToImport.getID() + "]");
                                }
                                else
                                if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.WORKSPACE) {
                                    inFeedback.println("Keep Workspace File: " + workpaceFile.getDBFilePath() + " [" + workpaceFile.getID() + "]");
                                }
                                else {
                                    // Left unresolved, so we fall back to skipping the record
                                    inFeedback.println("Skipped File: " + workpaceFile.getDBFilePath() + " [" + workpaceFile.getID() + "]");
                                }
                            }
                        }
                    }
                    catch (IOException ex) {
                        WildLogApp.LOGGER.log(Level.ERROR, ex.toString(), ex);
                    }
                }
            }
        }
    }

    private void copyFile(WildLogFile fileToImport) {
        // Copy the original file into the workspace
        UtilsFileProcessing.copyFile(
                importWorkspace.resolve(fileToImport.getRelativePath()).toAbsolutePath(),
                fileToImport.getAbsolutePath(), false, true);
        // Resize the file (if the option was selected)
        if (rdbImportThumbnails.isSelected()) {
            try {
                UtilsImageProcessing.resizeImage(fileToImport, ((WildLogThumbnailSizes) cmbThumbnailSize.getSelectedItem()).getSize());
            }
            catch (Exception ex) {
                WildLogApp.LOGGER.log(Level.WARN, "Could not resize the image during the import process: {}", fileToImport.getAbsolutePath().toString());
                // Sometimes the resize might fail for certain types of images, 
                // then we don't want to crash the process, but just continue to the next file
                WildLogApp.LOGGER.log(Level.WARN, ex.toString(), ex);
            }
        }
        // Create thumbnails
        if (WildLogFileType.IMAGE.equals(fileToImport.getFileType())) {
            fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.VERY_SMALL);
            fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.SMALL);
            fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.MEDIUM_SMALL);
            fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.NORMAL);
        }
    }

    private void rdbImportAllFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportAllFilesActionPerformed
       if (rdbImportAllFiles.isSelected()) {
           rdbImportOriginalImages.setEnabled(true);
           rdbImportThumbnails.setEnabled(true);
       }
    }//GEN-LAST:event_rdbImportAllFilesActionPerformed

    private void rdbImportImagesOnlyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportImagesOnlyActionPerformed
        if (rdbImportImagesOnly.isSelected()) {
           rdbImportOriginalImages.setEnabled(true);
           rdbImportThumbnails.setEnabled(true);
       }
    }//GEN-LAST:event_rdbImportImagesOnlyActionPerformed

    private void rdbImportNoFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportNoFilesActionPerformed
        if (rdbImportNoFiles.isSelected()) {
           rdbImportOriginalImages.setEnabled(false);
           rdbImportThumbnails.setEnabled(false);
       }
    }//GEN-LAST:event_rdbImportNoFilesActionPerformed

    private void treWorkspaceMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_treWorkspaceMousePressed
        // Gebruk die muis se posisie om die node te kry want die LastSelected node is verkeerd, vberal as mens die +/- gebruik om te expand/colapse...
        TreePath clickedPath = treWorkspace.getPathForLocation(evt.getX(), evt.getY());
        if (clickedPath != null && clickedPath.getLastPathComponent() != null) {
            if (((DefaultMutableTreeNode) clickedPath.getLastPathComponent()).getUserObject() instanceof WorkspaceTreeDataWrapper) {
                // Get the selected node and change the isSelected property
                WorkspaceTreeDataWrapper dataWrapper = (WorkspaceTreeDataWrapper) ((DefaultMutableTreeNode) clickedPath.getLastPathComponent()).getUserObject();
                dataWrapper.setIsSelected(!dataWrapper.isSelected());
                // Also update all sub nodes
                if (!evt.isControlDown() || !dataWrapper.isSelected()) {
                    selectChildren((DefaultMutableTreeNode) clickedPath.getLastPathComponent());
                }
                if (dataWrapper.isSelected()) {
                    selectParent((DefaultMutableTreeNode) clickedPath.getLastPathComponent());
                }
            }
            // Need to repaint the tree to make sure all icons are refreshed, otherwise Java does the "smart" thing and and caches painted nodes lower down.
            treWorkspace.repaint();
        }
    }//GEN-LAST:event_treWorkspaceMousePressed

    private void selectChildren(DefaultMutableTreeNode inParentNode) {
        for (int t = 0; t < treWorkspace.getModel().getChildCount(inParentNode); t++) {
            DefaultMutableTreeNode childNode = (DefaultMutableTreeNode) treWorkspace.getModel().getChild(inParentNode, t);
            WorkspaceTreeDataWrapper dataWrapper = (WorkspaceTreeDataWrapper) childNode.getUserObject();
            dataWrapper.setIsSelected(((WorkspaceTreeDataWrapper) inParentNode.getUserObject()).isSelected());
            selectChildren(childNode);
        }
    }

    private void selectParent(DefaultMutableTreeNode inNode) {
        if (((DefaultMutableTreeNode) inNode.getParent()).getUserObject() instanceof WorkspaceTreeDataWrapper) {
            ((WorkspaceTreeDataWrapper) ((DefaultMutableTreeNode) inNode.getParent()).getUserObject()).setIsSelected(
                    ((WorkspaceTreeDataWrapper) inNode.getUserObject()).isSelected());
            selectParent((DefaultMutableTreeNode) inNode.getParent());
        }
    }

    private void rdbOrderByLocationActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbOrderByLocationActionPerformed
        if (rdbOrderByLocation.isSelected()) {
            // Load the tree
            loadLocationTree();
        }
    }//GEN-LAST:event_rdbOrderByLocationActionPerformed

    private void rdbOrderByElementActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbOrderByElementActionPerformed
        if (rdbOrderByElement.isSelected()) {
            loadElementTree();
        }
    }//GEN-LAST:event_rdbOrderByElementActionPerformed

    private void formWindowClosed(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosed
        if (importDBI != null) {
            importDBI.close();
        }
    }//GEN-LAST:event_formWindowClosed

    private void btnCheckConflictsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCheckConflictsActionPerformed
        getGlassPane().setVisible(true);
        getGlassPane().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        int conflicts = 0;
        int totalSelectedNodes = getNumberOfSelectedNodes(treWorkspace.getModel(), (DefaultMutableTreeNode) treWorkspace.getModel().getRoot());
        if (totalSelectedNodes > 0) {
            conflicts = checkConflicts((DefaultMutableTreeNode) treWorkspace.getModel().getRoot(), new HashSet<>());
        }
        getGlassPane().setCursor(Cursor.getDefaultCursor());
        getGlassPane().setVisible(false);
        if (conflicts > 0) {
            WLOptionPane.showMessageDialog(this,
                    "<html>Importing the selected records will result in <b>" + conflicts + " potential conflicts</b>. "
                            + "<br>Conflicts can be resolved during the import process.</html>",
                    "Potential Conflicts Detected!", JOptionPane.WARNING_MESSAGE);
        }
        else {
            WLOptionPane.showMessageDialog(this,
                    "No import conflicts were detected for the selected records.",
                    "No Conflicts Detected", JOptionPane.INFORMATION_MESSAGE);
        }
    }//GEN-LAST:event_btnCheckConflictsActionPerformed

    private void rdbImportOriginalImagesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportOriginalImagesActionPerformed
        if (rdbImportOriginalImages.isSelected()) {
            cmbThumbnailSize.setEnabled(false);
        }
    }//GEN-LAST:event_rdbImportOriginalImagesActionPerformed

    private void rdbImportThumbnailsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportThumbnailsActionPerformed
        if (rdbImportThumbnails.isSelected()) {
            cmbThumbnailSize.setEnabled(true);
        }
    }//GEN-LAST:event_rdbImportThumbnailsActionPerformed

    private int checkConflicts(DefaultMutableTreeNode inNode, Set<String> inProcessedData) {
        int conflict = 0;
        if (inNode.getUserObject() instanceof WorkspaceTreeDataWrapper) {
            WorkspaceTreeDataWrapper dataWrapper = (WorkspaceTreeDataWrapper) inNode.getUserObject();
            if (dataWrapper.isSelected()) {
                // Check the record
                if (dataWrapper.getDataObject() instanceof Location) {
                    if (inProcessedData.add("L" + ((Location) dataWrapper.getDataObject()).getID())) {
                        Location importLocation = importDBI.findLocation(((Location) dataWrapper.getDataObject()).getID(), null, false, Location.class);
                        Location workspaceLocation = WildLogApp.getApplication().getDBI().findLocation(importLocation.getID(), null, false, Location.class);
                        if (workspaceLocation != null) {
                            if (!importLocation.hasTheSameContent(workspaceLocation)) {
                                conflict = 1;
                            }
                        }
                        conflict = conflict + checkFileConflicts(importLocation.getWildLogFileID());
                    }
                }
                else
                if (dataWrapper.getDataObject() instanceof Visit) {
                    if (inProcessedData.add("V" + ((Visit) dataWrapper.getDataObject()).getID())) {
                        Visit importVisit = importDBI.findVisit(((Visit) dataWrapper.getDataObject()).getID(), null, true, Visit.class);
                        Visit workspaceVisit = WildLogApp.getApplication().getDBI().findVisit(importVisit.getID(), null, true, Visit.class);
                        if (workspaceVisit != null) {
                            if (!importVisit.hasTheSameContent(workspaceVisit)) {
                                conflict = 1;
                            }
                        }
                        conflict = conflict + checkFileConflicts(importVisit.getWildLogFileID());
                    }
                }
                else
                if (dataWrapper.getDataObject() instanceof Element) {
                    if (inProcessedData.add("E" + ((Element) dataWrapper.getDataObject()).getID())) {
                        Element importElement = importDBI.findElement(((Element) dataWrapper.getDataObject()).getID(), null, false, Element.class);
                        Element workspaceElement = WildLogApp.getApplication().getDBI().findElement(importElement.getID(), null, false, Element.class);
                        if (workspaceElement != null) {
                            if (!importElement.hasTheSameContent(workspaceElement)) {
                                conflict = 1;
                            }
                        }
                        conflict = conflict + checkFileConflicts(importElement.getWildLogFileID());
                    }
                }
                else
                if (dataWrapper.getDataObject() instanceof SightingWrapper) {
                    Sighting importSighting = importDBI.findSighting((((SightingWrapper) dataWrapper.getDataObject()).getSighting()).getID(), true, Sighting.class);
                    Sighting workpaceSighting = WildLogApp.getApplication().getDBI().findSighting(importSighting.getID(), true, Sighting.class);
                    if (workpaceSighting != null) {
                        if (!importSighting.hasTheSameContent(workpaceSighting)) {
                            conflict = 1;
                        }
                    }
                    conflict = conflict + checkFileConflicts(importSighting.getWildLogFileID());
                }
            }
        }
        for (int t = 0; t < treWorkspace.getModel().getChildCount(inNode); t++) {
            DefaultMutableTreeNode childNode = (DefaultMutableTreeNode) treWorkspace.getModel().getChild(inNode, t);
            conflict = conflict + checkConflicts(childNode, inProcessedData);
        }
        return conflict;
    }
    
    private int checkFileConflicts(long inWildLogFileID) {
        int conflicts = 0;
        if (!rdbImportNoFiles.isSelected()) {
            WildLogFileType fileType = null;
            if (rdbImportImagesOnly.isSelected()) {
                fileType = WildLogFileType.IMAGE;
            }
            List<WildLogFile> listExternalFiles = importDBI.listWildLogFiles(inWildLogFileID, fileType, WildLogFile.class);
            for (WildLogFile fileToImport : listExternalFiles) {
                if (WildLogApp.getApplication().getDBI().countWildLogFiles(fileToImport.getID(), 0) != 0) {
                    WildLogFile workpaceFile = WildLogApp.getApplication().getDBI().findWildLogFile(fileToImport.getID(), 0, null, null, WildLogFile.class);
                    try {
                        if (Files.size(importWorkspace.resolve(fileToImport.getRelativePath()).toAbsolutePath()) != Files.size(workpaceFile.getAbsolutePath())) {
                            conflicts++;
                        }
                    }
                    catch (IOException ex) {
                        WildLogApp.LOGGER.log(Level.ERROR, ex.toString(), ex);
                    }
                }
            }
        }
        return conflicts;
    }
    
    private void loadLocationTree() {
        DefaultMutableTreeNode root = new DefaultMutableTreeNode("WildLog Workspace");
        List<Location> locations = new ArrayList<Location>(importDBI.listLocations(null, false, Location.class));
        Map<Long, DefaultMutableTreeNode> mapElements;
        Map<Long, DefaultMutableTreeNode> mapVisits;
        Collections.sort(locations);
        for (Location location : locations) {
            mapElements = new HashMap<>(500);
            mapVisits = new HashMap<>(500);
            DefaultMutableTreeNode locationNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(location, false));
            root.add(locationNode);
            List<Sighting> sightings = importDBI.listSightings(0, location.getID(), 0, true, Sighting.class);
            Collections.sort(sightings, new Comparator<Sighting>() {
                @Override
                public int compare(Sighting sighting1, Sighting sighting2) {
                    int result = Long.compare(sighting1.getVisitID(), sighting2.getVisitID());
                    if (result == 0) {
                        result = Long.compare(sighting1.getElementID(), sighting2.getElementID());
                        if (result == 0) {
                            result = sighting1.getDate().compareTo(sighting2.getDate());
                        }
                    }
                    return result;
                }
            });
            for (Sighting sighting : sightings) {
                DefaultMutableTreeNode visitNode = mapVisits.get(sighting.getVisitID());
                if (visitNode == null) {
                    visitNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(importDBI.findVisit(sighting.getVisitID(), null, true, Visit.class), false));
                    mapVisits.put(sighting.getVisitID(), visitNode);
                    // Clear die hashmap hier as 'n nuwe visit gelaai word (die sightings behoort volgens visit gesort te wees, so die visit sal nie weer verskyn nie.
                    mapElements.clear();
                }
                locationNode.add(visitNode);
                DefaultMutableTreeNode elementNode = mapElements.get(sighting.getElementID());
                if (elementNode == null) {
                    elementNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(importDBI.findElement(sighting.getElementID(), null, false, Element.class), false));
                    mapElements.put(sighting.getElementID(), elementNode);
                }
                visitNode.add(elementNode);
                DefaultMutableTreeNode sightingNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(new SightingWrapper(sighting, true), false));
                elementNode.add(sightingNode);
            }
        }
        treWorkspace.setModel(new DefaultTreeModel(root));
    }

    private void loadElementTree() {
        DefaultMutableTreeNode root = new DefaultMutableTreeNode("WildLog Workspace");
        List<Element> elements = new ArrayList<Element>(importDBI.listElements(null, null, null, false, Element.class));
        Map<Long, DefaultMutableTreeNode> mapLocations;
        Map<Long, DefaultMutableTreeNode> mapVisits;
        Collections.sort(elements);
        for (Element element : elements) {
            mapLocations = new HashMap<>(100);
            mapVisits = new HashMap<>(500);
            DefaultMutableTreeNode elementNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(element, false));
            root.add(elementNode);
            List<Sighting> sightings = importDBI.listSightings(element.getID(), 0, 0, true, Sighting.class);
            Collections.sort(sightings, new Comparator<Sighting>() {
                @Override
                public int compare(Sighting sighting1, Sighting sighting2) {
                    int result = Long.compare(sighting1.getLocationID(), sighting2.getLocationID());
                    if (result == 0) {
                        result = Long.compare(sighting1.getVisitID(), sighting2.getVisitID());
                        if (result == 0) {
                            result = sighting1.getDate().compareTo(sighting2.getDate());
                        }
                    }
                    return result;
                }
            });
            for (Sighting sighting : sightings) {
                DefaultMutableTreeNode locationNode = mapLocations.get(sighting.getLocationID());
                if (locationNode == null) {
                    locationNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(importDBI.findLocation(sighting.getLocationID(), null, false, Location.class), false));
                    mapLocations.put(sighting.getLocationID(), locationNode);
                }
                elementNode.add(locationNode);
                DefaultMutableTreeNode visitNode = mapVisits.get(sighting.getVisitID());
                if (visitNode == null) {
                    visitNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(importDBI.findVisit(sighting.getVisitID(), null, true, Visit.class), false));
                    mapVisits.put(sighting.getVisitID(), visitNode);
                }
                locationNode.add(visitNode);
                DefaultMutableTreeNode sightingNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(new SightingWrapper(sighting, true), false));
                visitNode.add(sightingNode);
            }
        }
        treWorkspace.setModel(new DefaultTreeModel(root));
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnCheckConflicts;
    private javax.swing.JButton btnConfirm;
    private javax.swing.JComboBox<WildLogThumbnailSizes> cmbThumbnailSize;
    private javax.swing.ButtonGroup grpConflicts;
    private javax.swing.ButtonGroup grpFiles;
    private javax.swing.ButtonGroup grpImages;
    private javax.swing.ButtonGroup grpTreeOrder;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JSeparator jSeparator3;
    private javax.swing.JRadioButton rdbConflictAsk;
    private javax.swing.JRadioButton rdbConflictAutoResolve;
    private javax.swing.JRadioButton rdbImportAllFiles;
    private javax.swing.JRadioButton rdbImportImagesOnly;
    private javax.swing.JRadioButton rdbImportNoFiles;
    private javax.swing.JRadioButton rdbImportOriginalImages;
    private javax.swing.JRadioButton rdbImportThumbnails;
    private javax.swing.JRadioButton rdbOrderByElement;
    private javax.swing.JRadioButton rdbOrderByLocation;
    private javax.swing.JTree treWorkspace;
    // End of variables declaration//GEN-END:variables
}
