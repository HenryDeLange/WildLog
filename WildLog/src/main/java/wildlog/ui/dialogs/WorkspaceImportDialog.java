package wildlog.ui.dialogs;

import java.awt.Cursor;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.swing.DefaultComboBoxModel;
import javax.swing.ImageIcon;
import javax.swing.JDialog;
import javax.swing.JOptionPane;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;
import org.apache.logging.log4j.Level;
import wildlog.WildLogApp;
import wildlog.data.dataobjects.Element;
import wildlog.data.dataobjects.Location;
import wildlog.data.dataobjects.Sighting;
import wildlog.data.dataobjects.Visit;
import wildlog.data.dataobjects.WildLogFile;
import wildlog.data.dataobjects.wrappers.SightingWrapper;
import wildlog.data.dbi.WildLogDBI;
import wildlog.data.dbi.WildLogDBI_h2;
import wildlog.data.enums.WildLogFileType;
import wildlog.data.enums.WildLogThumbnailSizes;
import wildlog.ui.dialogs.utils.UtilsDialog;
import wildlog.ui.helpers.ProgressbarTask;
import wildlog.ui.helpers.WLOptionPane;
import wildlog.ui.helpers.renderers.WorkspaceTreeCellRenderer;
import wildlog.ui.helpers.renderers.WorkspaceTreeDataWrapper;
import wildlog.utils.UtilsConcurency;
import wildlog.utils.UtilsFileProcessing;
import wildlog.utils.UtilsImageProcessing;
import wildlog.utils.WildLogPaths;


public class WorkspaceImportDialog extends JDialog {
    private WildLogApp app;
    private Path importWorkspace;
    private WildLogDBI importDBI = null;
    private int importLocationTotal = 0;
    private int importVisitTotal = 0;
    private int importElementTotal = 0;
    private int importSightingTotal = 0;
    private int importFileTotal = 0;
    private int importLocationConflicts = 0;
    private int importVisitConflicts = 0;
    private int importElementConflicts = 0;
    private int importSightingConflicts = 0;
    private int importFileConflicts = 0;


    public WorkspaceImportDialog(WildLogApp inApp, Path inImportPath) {
        super();
        WildLogApp.LOGGER.log(Level.INFO, "[WorkspaceImportDialog]");
        app = inApp;
        importWorkspace = inImportPath;
        try {
        importDBI = new WildLogDBI_h2((importWorkspace.resolve(WildLogPaths.WILDLOG_DATA.getRelativePath()).resolve(
                WildLogPaths.DEFAULT_DATABASE_NAME.getRelativePath())).toAbsolutePath().toString(), false, false);
        }
        catch (Exception ex) {
            WildLogApp.LOGGER.log(Level.ERROR, ex.toString(), ex);
        }
        initComponents();
        // Setup the tree
        treWorkspace.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        treWorkspace.setCellRenderer(new WorkspaceTreeCellRenderer());
        treWorkspace.setToggleClickCount(0);
        // Load the tree
        loadLocationTree();
        // Setup the default behavior
        UtilsDialog.setDialogToCenter(app.getMainFrame(), this);
        UtilsDialog.addEscapeKeyListener(this);
        // Setup the glasspane on this dialog as well for the JOptionPane's
        UtilsDialog.addModalBackgroundPanel(app.getMainFrame(), this);
        UtilsDialog.addModalBackgroundPanel(this, null);
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        grpFiles = new javax.swing.ButtonGroup();
        grpImages = new javax.swing.ButtonGroup();
        grpTreeOrder = new javax.swing.ButtonGroup();
        grpConflicts = new javax.swing.ButtonGroup();
        btnConfirm = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        treWorkspace = new javax.swing.JTree();
        jLabel2 = new javax.swing.JLabel();
        rdbImportAllFiles = new javax.swing.JRadioButton();
        rdbImportImagesOnly = new javax.swing.JRadioButton();
        rdbImportNoFiles = new javax.swing.JRadioButton();
        jSeparator1 = new javax.swing.JSeparator();
        rdbImportOriginalImages = new javax.swing.JRadioButton();
        rdbImportThumbnails = new javax.swing.JRadioButton();
        jLabel1 = new javax.swing.JLabel();
        rdbOrderByLocation = new javax.swing.JRadioButton();
        rdbOrderByElement = new javax.swing.JRadioButton();
        jLabel3 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        rdbConflictAutoResolve = new javax.swing.JRadioButton();
        rdbConflictAsk = new javax.swing.JRadioButton();
        jSeparator2 = new javax.swing.JSeparator();
        jSeparator3 = new javax.swing.JSeparator();
        btnCheckConflicts = new javax.swing.JButton();
        cmbThumbnailSize = new javax.swing.JComboBox<>();
        jLabel7 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Import From An External Workspace");
        setIconImage(new ImageIcon(app.getClass().getResource("resources/icons/WildLog Icon Small.gif")).getImage());
        setMinimumSize(new java.awt.Dimension(850, 700));
        setModal(true);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosed(java.awt.event.WindowEvent evt) {
                formWindowClosed(evt);
            }
        });

        btnConfirm.setIcon(new javax.swing.ImageIcon(getClass().getResource("/wildlog/resources/icons/Update.png"))); // NOI18N
        btnConfirm.setToolTipText("Import the selected records to the active Workspace.");
        btnConfirm.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnConfirm.setFocusPainted(false);
        btnConfirm.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnConfirmActionPerformed(evt);
            }
        });

        javax.swing.tree.DefaultMutableTreeNode treeNode1 = new javax.swing.tree.DefaultMutableTreeNode("root");
        treWorkspace.setModel(new javax.swing.tree.DefaultTreeModel(treeNode1));
        treWorkspace.setFocusable(false);
        treWorkspace.setRequestFocusEnabled(false);
        treWorkspace.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                treWorkspaceMousePressed(evt);
            }
        });
        jScrollPane1.setViewportView(treWorkspace);

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel2.setText("Files:");

        grpFiles.add(rdbImportAllFiles);
        rdbImportAllFiles.setSelected(true);
        rdbImportAllFiles.setText("All Files");
        rdbImportAllFiles.setToolTipText("Import all files into the current Workspace.");
        rdbImportAllFiles.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportAllFiles.setFocusPainted(false);
        rdbImportAllFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportAllFilesActionPerformed(evt);
            }
        });

        grpFiles.add(rdbImportImagesOnly);
        rdbImportImagesOnly.setText("Images Only");
        rdbImportImagesOnly.setToolTipText("Import only image files into the current Workspace.");
        rdbImportImagesOnly.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportImagesOnly.setFocusPainted(false);
        rdbImportImagesOnly.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportImagesOnlyActionPerformed(evt);
            }
        });

        grpFiles.add(rdbImportNoFiles);
        rdbImportNoFiles.setText("No Files");
        rdbImportNoFiles.setToolTipText("Don't import any files into the current Workspace.");
        rdbImportNoFiles.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportNoFiles.setFocusPainted(false);
        rdbImportNoFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportNoFilesActionPerformed(evt);
            }
        });

        jSeparator1.setOrientation(javax.swing.SwingConstants.VERTICAL);

        grpImages.add(rdbImportOriginalImages);
        rdbImportOriginalImages.setSelected(true);
        rdbImportOriginalImages.setText("Original Images");
        rdbImportOriginalImages.setToolTipText("Import a copy of the original linked images into the current Workspace.");
        rdbImportOriginalImages.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportOriginalImages.setFocusPainted(false);
        rdbImportOriginalImages.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportOriginalImagesActionPerformed(evt);
            }
        });

        grpImages.add(rdbImportThumbnails);
        rdbImportThumbnails.setText("Thumbnail Images");
        rdbImportThumbnails.setToolTipText("The images that are imported will be reduced in size, the original images will not be imported.");
        rdbImportThumbnails.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportThumbnails.setFocusPainted(false);
        rdbImportThumbnails.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportThumbnailsActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel1.setText("Sort Order:");

        grpTreeOrder.add(rdbOrderByLocation);
        rdbOrderByLocation.setSelected(true);
        rdbOrderByLocation.setText("Order by Place");
        rdbOrderByLocation.setToolTipText("Order the tree nodes by Places, then Periods and lastly Creatures.");
        rdbOrderByLocation.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbOrderByLocation.setFocusPainted(false);
        rdbOrderByLocation.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbOrderByLocationActionPerformed(evt);
            }
        });

        grpTreeOrder.add(rdbOrderByElement);
        rdbOrderByElement.setText("Order by Creature");
        rdbOrderByElement.setToolTipText("Order the tree nodes by Creatures, then Places and lastly Periods.");
        rdbOrderByElement.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbOrderByElement.setFocusPainted(false);
        rdbOrderByElement.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbOrderByElementActionPerformed(evt);
            }
        });

        jLabel3.setText("<html><i>The records marked with the WildLog (W) icon will be imported. Hold down the Ctrl key to select only the record, without it's sub-records.</i></html>");

        jLabel5.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel5.setText("Conflicts:");

        grpConflicts.add(rdbConflictAutoResolve);
        rdbConflictAutoResolve.setSelected(true);
        rdbConflictAutoResolve.setText("Automatically choose the most recently edited record and largest file");
        rdbConflictAutoResolve.setToolTipText("<html>When the active Workspace and the imported Workspace contains records with the same IDs but different data fields then the most recently edited record will automatically be used in the active Workspace.</html>");
        rdbConflictAutoResolve.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbConflictAutoResolve.setFocusPainted(false);

        grpConflicts.add(rdbConflictAsk);
        rdbConflictAsk.setText("Ask what to do for each conflict");
        rdbConflictAsk.setToolTipText("<html>When the active Workspace and the imported Workspace contains records with the same IDs but different data fields then the user will be asked which record to use in the active Workspace.</html>");
        rdbConflictAsk.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbConflictAsk.setFocusPainted(false);

        btnCheckConflicts.setText("<html>Check for Conflicts</html>");
        btnCheckConflicts.setToolTipText("Checks how many conflicts there will be when importing using the selected records.");
        btnCheckConflicts.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnCheckConflicts.setFocusPainted(false);
        btnCheckConflicts.setMargin(new java.awt.Insets(2, 2, 2, 2));
        btnCheckConflicts.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCheckConflictsActionPerformed(evt);
            }
        });

        cmbThumbnailSize.setMaximumRowCount(15);
        cmbThumbnailSize.setModel(new DefaultComboBoxModel(WildLogThumbnailSizes.values()));
        cmbThumbnailSize.setSelectedItem(WildLogThumbnailSizes.VERY_LARGE);
        cmbThumbnailSize.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        cmbThumbnailSize.setEnabled(false);
        cmbThumbnailSize.setFocusable(false);

        jLabel7.setText("px");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addGap(10, 10, 10)
                                .addComponent(rdbImportAllFiles)
                                .addGap(5, 5, 5)
                                .addComponent(rdbImportImagesOnly)
                                .addGap(5, 5, 5)
                                .addComponent(rdbImportNoFiles)
                                .addGap(10, 10, 10)
                                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(10, 10, 10)
                                .addComponent(rdbImportOriginalImages)
                                .addGap(5, 5, 5)
                                .addComponent(rdbImportThumbnails)
                                .addGap(5, 5, 5)
                                .addComponent(cmbThumbnailSize, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(5, 5, 5)
                                .addComponent(jLabel7)
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel5)
                                        .addGap(10, 10, 10)
                                        .addComponent(rdbConflictAutoResolve)
                                        .addGap(5, 5, 5)
                                        .addComponent(rdbConflictAsk))
                                    .addComponent(jSeparator2))
                                .addGap(5, 5, 5))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jSeparator3)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(1, 1, 1)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel1)
                                        .addGap(10, 10, 10)
                                        .addComponent(rdbOrderByLocation)
                                        .addGap(5, 5, 5)
                                        .addComponent(rdbOrderByElement)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 80, Short.MAX_VALUE)))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(btnConfirm, javax.swing.GroupLayout.PREFERRED_SIZE, 110, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(btnCheckConflicts, javax.swing.GroupLayout.PREFERRED_SIZE, 110, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addGap(5, 5, 5))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jSeparator1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(rdbImportOriginalImages)
                                    .addComponent(rdbImportThumbnails)
                                    .addComponent(rdbImportImagesOnly)
                                    .addComponent(rdbImportAllFiles)
                                    .addComponent(rdbImportNoFiles)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(jLabel7)
                                        .addComponent(cmbThumbnailSize, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))))
                        .addGap(5, 5, 5)
                        .addComponent(jSeparator3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(5, 5, 5)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(rdbConflictAutoResolve, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(rdbConflictAsk, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(5, 5, 5)
                        .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(5, 5, 5)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(rdbOrderByLocation)
                            .addComponent(rdbOrderByElement))
                        .addGap(5, 5, 5)
                        .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(btnConfirm, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(5, 5, 5)
                        .addComponent(btnCheckConflicts, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(2, 2, 2)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 566, Short.MAX_VALUE)
                .addGap(5, 5, 5))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnConfirmActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnConfirmActionPerformed
        try {
            if (importWorkspace != null) {
                UtilsConcurency.kickoffProgressbarTask(app, new ProgressbarTask(app) {
                    @Override
                    protected Object doInBackground() throws Exception {
                        app.getMainFrame().getGlassPane().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
                        setProgress(1);
                        setMessage("Starting the Workspace Import");
                        setVisible(false);
                        try {
                            int totalSelectedNodes = getNumberOfSelectedNodes(treWorkspace.getModel(), (DefaultMutableTreeNode) treWorkspace.getModel().getRoot());
                            if (totalSelectedNodes > 0) {
                                Path feedbackFile = WildLogPaths.getFullWorkspacePrefix().resolve("iNaturalistWildLogLinkReport.txt");
                                PrintWriter feedback = null;
                                try {
                                    feedback = new PrintWriter(new FileWriter(feedbackFile.toFile()), true);
                                    feedback.println("---------------------------------------------");
                                    feedback.println("---------- Workspace Import Report ----------");
                                    feedback.println("---------------------------------------------");
                                    feedback.println("");
                                    setProgress(2);
                                    setMessage("Workspace Import: " + getProgress() + "%");
                                    // Only process Elements, Locations and Visits once (can be multiple times in the tree)
                                    Set<String> processedData = new HashSet<>();
                                    // Start processing
                                    importRecords((DefaultMutableTreeNode) treWorkspace.getModel().getRoot(), totalSelectedNodes, this, new ProgressCounter(), processedData, feedback);
                                    // Write summary
                                    int importTotal = importLocationTotal + importVisitTotal + importElementTotal + importSightingTotal + importFileTotal;
                                    int importConflicts = importLocationConflicts + importVisitConflicts + importElementConflicts + importSightingConflicts + importFileConflicts;
                                    WildLogApp.LOGGER.log(Level.INFO, "Imported {} records successfully, of which {} were conflicts.", importTotal, importConflicts);
                                    feedback.println("");
                                    feedback.println("-------------- SUMMARY --------------");
                                    feedback.println("TOTAL IMPORTED RECORDS      : " + importTotal);
                                    feedback.println("TOTAL CONFLICTS             : " + importConflicts);
                                    feedback.println("");
                                    feedback.println("Places imported             : " + importLocationTotal);
                                    feedback.println("Places with conflicts       : " + importLocationConflicts);
                                    feedback.println("Periods imported            : " + importVisitTotal);
                                    feedback.println("Periods with conflicts      : " + importVisitConflicts);
                                    feedback.println("Creatures imported          : " + importElementTotal);
                                    feedback.println("Creatures with conflicts    : " + importElementConflicts);
                                    feedback.println("Observations imported       : " + importSightingTotal);
                                    feedback.println("Observations with conflicts : " + importSightingConflicts);
                                    feedback.println("Files imported              : " + importFileTotal);
                                    feedback.println("Files with conflicts        : " + importFileConflicts);
                                    setProgress(100);
                                    setMessage("Workspace Import: " + getProgress() + "%");
                                }
                                catch (Exception ex) {
                                    if (feedback != null) {
                                        feedback.println("");
                                        feedback.println("--------------------------------------");
                                        feedback.println("--------------- ERROR ----------------");
                                        feedback.println(ex.toString());
                                        feedback.println("--------------------------------------");
                                        feedback.println("");
                                    }
                                    throw ex;
                                }
                                finally {
                                    if (feedback != null) {
                                        feedback.println("");
                                        feedback.println("--------------------------------------");
                                        feedback.println("-------------- FINISHED --------------");
                                        feedback.println("--------------------------------------");
                                        feedback.println("");
                                        feedback.flush();
                                        feedback.close();
                                        // Open the summary document
                                        UtilsFileProcessing.openFile(feedbackFile);
                                    }
                                }
                            }
                        }
                        catch (Exception ex) {
                            throw ex;
                        }
                        finally {
                            app.getMainFrame().refreshHomeTab();
                            setVisible(false);
                            dispose();
                            if (importDBI != null) {
                                importDBI.close();
                            }
                        }
                        setProgress(100);
                        setMessage("Done with the Workspace Import");
                        app.getMainFrame().getGlassPane().setCursor(Cursor.getDefaultCursor());
                        return null;
                    }
                });
            }
        }
        catch (Exception ex) {
            WildLogApp.LOGGER.log(Level.ERROR, ex.toString(), ex);
            WLOptionPane.showMessageDialog(app.getMainFrame(),
                    "Could not import the Workspace successfully.",
                    "Import Workspace Error", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_btnConfirmActionPerformed

    private class ProgressCounter {
        public int counter = 0;
    }

    private int getNumberOfSelectedNodes(TreeModel inModel, DefaultMutableTreeNode inNode) {
        int count = 0;
        if (inNode.getUserObject() instanceof WorkspaceTreeDataWrapper) {
            WorkspaceTreeDataWrapper dataWrapper = (WorkspaceTreeDataWrapper) inNode.getUserObject();
            if (dataWrapper.isSelected()) {
                count = 1;
            }
        }
        int numberOfChildren = inModel.getChildCount(inNode);
        for (int i = 0; i < numberOfChildren; i++) {
            count += getNumberOfSelectedNodes(inModel, (DefaultMutableTreeNode) inModel.getChild(inNode, i));
        }
        return count;
    }

    private void importRecords(DefaultMutableTreeNode inNode, int inTotalNodes, ProgressbarTask inProgressbarTask, ProgressCounter inCounter, 
            Set<String> inProcessedData, PrintWriter inFeedback) {
        if (inNode.getUserObject() instanceof WorkspaceTreeDataWrapper) {
            WorkspaceTreeDataWrapper dataWrapper = (WorkspaceTreeDataWrapper) inNode.getUserObject();
            if (dataWrapper.isSelected()) {
                if (dataWrapper.getDataObject() instanceof Location) {
                    if (inProcessedData.add("L" + ((Location) dataWrapper.getDataObject()).getID())) {
                        Location importLocation = importDBI.findLocation(((Location) dataWrapper.getDataObject()).getID(), null, Location.class);
                        // Check to make sure the name of the importing records is unique the active workspace
                        Location checkWorkspaceName = app.getDBI().findLocation(0, importLocation.getName(), Location.class);
                        while (checkWorkspaceName != null && checkWorkspaceName.getID() != importLocation.getID()) {
                            importLocation.setName("wlimport_" + importLocation.getName());
                            checkWorkspaceName = app.getDBI().findLocation(0, importLocation.getName(), Location.class);
                        }
                        // Save the new record
                        Location workspaceLocation = app.getDBI().findLocation(importLocation.getID(), null, Location.class);
                        if (workspaceLocation == null) {
                            // New
                            app.getDBI().createLocation(importLocation, true);
                            importLocationTotal++;
                            inFeedback.println("Imported Place: " + importLocation.getDisplayName() + " [" + importLocation.getID() + "]");
                        }
                        else {
                            // Update
                            if (!importLocation.hasTheSameContent(workspaceLocation)) {
                                importLocationConflicts++;
                                if (rdbConflictAutoResolve.isSelected()) {
                                    if (importLocation.getAuditTime() > workspaceLocation.getAuditTime()) {
                                        app.getDBI().updateLocation(importLocation, importLocation.getName(), true);
                                        importLocationTotal++;
                                        inFeedback.println("Auto Updated Place: " + importLocation.getDisplayName() + " [" + importLocation.getID() + "]");
                                    }
                                }
                                else {
                                    WorkspaceImportConflictDialog dialog = new WorkspaceImportConflictDialog(importLocation, workspaceLocation);
                                    dialog.setVisible(true);
                                    if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.IMPORT) {
                                        app.getDBI().updateLocation(importLocation, importLocation.getName(), true);
                                        importLocationTotal++;
                                        inFeedback.println("Manual Updated Place: " + importLocation.getDisplayName() + " [" + importLocation.getID() + "]");
                                    }
                                    else
                                    if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.WORKSPACE) {
                                        inFeedback.println("Keep Workspace Place: " + workspaceLocation.getDisplayName() + " [" + workspaceLocation.getID() + "]");
                                    }
                                    else {
                                        // Left unresolved, so we fall back to skipping the record
                                        inFeedback.println("Skipped Place: " + workspaceLocation.getDisplayName() + " [" + workspaceLocation.getID() + "]");
                                    }
                                }
                            }
                        }
                        saveFiles(importLocation.getWildLogFileID(), inFeedback);
                    }
                }
                else
                if (dataWrapper.getDataObject() instanceof Visit) {
                    if (inProcessedData.add("V" + ((Visit) dataWrapper.getDataObject()).getID())) {
                        Visit importVisit = importDBI.findVisit(((Visit) dataWrapper.getDataObject()).getID(), null, true, Visit.class);
                        // Check to make sure the name of the importing records is unique the active workspace
                        Visit checkWorkspaceName = app.getDBI().findVisit(0, importVisit.getName(), false, Visit.class);
                        while (checkWorkspaceName != null && checkWorkspaceName.getID() != importVisit.getID()) {
                            importVisit.setName("wlimport_" + importVisit.getName());
                            checkWorkspaceName = app.getDBI().findVisit(0, importVisit.getName(), false, Visit.class);
                        }
                        // Save the new record
                        Visit workspaceVisit = app.getDBI().findVisit(importVisit.getID(), null, true, Visit.class);
                        if (workspaceVisit == null) {
                            // New
                            app.getDBI().createVisit(importVisit, true);
                            importVisitTotal++;
                            inFeedback.println("Imported Period: " + importVisit.getDisplayName() + " [" + importVisit.getID() + "]");
                        }
                        else {
                            // Update
                            if (!importVisit.hasTheSameContent(workspaceVisit)) {
                                importVisitConflicts++;
                                if (rdbConflictAutoResolve.isSelected()) {
                                    if (importVisit.getAuditTime() > workspaceVisit.getAuditTime()) {
                                        app.getDBI().updateVisit(importVisit, importVisit.getName(), true);
                                        importVisitTotal++;
                                        inFeedback.println("Auto Updated Period: " + importVisit.getDisplayName() + " [" + importVisit.getID() + "]");
                                    }
                                }
                                else {
                                    WorkspaceImportConflictDialog dialog = new WorkspaceImportConflictDialog(importVisit, workspaceVisit);
                                    dialog.setVisible(true);
                                    if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.IMPORT) {
                                        app.getDBI().updateVisit(importVisit, importVisit.getName(), true);
                                        importVisitTotal++;
                                        inFeedback.println("Manual Updated Period: " + importVisit.getDisplayName() + " [" + importVisit.getID() + "]");
                                    }
                                    else
                                    if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.WORKSPACE) {
                                        inFeedback.println("Keep Workspace Period: " + workspaceVisit.getDisplayName() + " [" + workspaceVisit.getID() + "]");
                                    }
                                    else {
                                        // Left unresolved, so we fall back to skipping the record
                                        inFeedback.println("Skipped Period: " + workspaceVisit.getDisplayName() + " [" + workspaceVisit.getID() + "]");
                                    }
                                }
                            }
                        }
                        saveFiles(importVisit.getWildLogFileID(), inFeedback);
                    }
                }
                else
                if (dataWrapper.getDataObject() instanceof Element) {
                    if (inProcessedData.add("E" + ((Element) dataWrapper.getDataObject()).getID())) {
                        Element importElement = importDBI.findElement(((Element) dataWrapper.getDataObject()).getID(), null, Element.class);
                        // Check to make sure the name of the importing records is unique the active workspace
                        Element checkWorkspaceName = app.getDBI().findElement(0, importElement.getPrimaryName(), Element.class);
                        while (checkWorkspaceName != null && checkWorkspaceName.getID() != importElement.getID()) {
                            importElement.setPrimaryName("wlimport_" + importElement.getPrimaryName());
                            checkWorkspaceName = app.getDBI().findElement(0, importElement.getPrimaryName(), Element.class);
                        }
                        // Save the new record
                        Element workspaceElement = app.getDBI().findElement(importElement.getID(), null, Element.class);
                        if (workspaceElement == null) {
                            // New
                            app.getDBI().createElement(importElement, true);
                            importElementTotal++;
                            inFeedback.println("Imported Creature: " + importElement.getDisplayName() + " [" + importElement.getID() + "]");
                        }
                        else {
                            // Update
                            if (!importElement.hasTheSameContent(workspaceElement)) {
                                importElementConflicts++;
                                if (rdbConflictAutoResolve.isSelected()) {
                                    if (importElement.getAuditTime() > workspaceElement.getAuditTime()) {
                                        app.getDBI().updateElement(importElement, importElement.getPrimaryName(), true);
                                        importElementTotal++;
                                        inFeedback.println("Auto Updated Creature: " + importElement.getDisplayName() + " [" + importElement.getID() + "]");
                                    }
                                }
                                else {
                                    WorkspaceImportConflictDialog dialog = new WorkspaceImportConflictDialog(importElement, workspaceElement);
                                    dialog.setVisible(true);
                                    if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.IMPORT) {
                                        app.getDBI().updateElement(importElement, importElement.getPrimaryName(), true);
                                        importElementTotal++;
                                        inFeedback.println("Manual Updated Creature: " + importElement.getDisplayName() + " [" + importElement.getID() + "]");
                                    }
                                    else
                                    if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.WORKSPACE) {
                                        inFeedback.println("Keep Workspace Creature: " + workspaceElement.getDisplayName() + " [" + workspaceElement.getID() + "]");
                                    }
                                    else {
                                        // Left unresolved, so we fall back to skipping the record
                                        inFeedback.println("Skipped Creature: " + workspaceElement.getDisplayName() + " [" + workspaceElement.getID() + "]");
                                    }
                                }
                            }
                        }
                        saveFiles(importElement.getWildLogFileID(), inFeedback);
                    }
                }
                else
                if (dataWrapper.getDataObject() instanceof SightingWrapper) {
                    Sighting importSighting = importDBI.findSighting((((SightingWrapper) dataWrapper.getDataObject()).getSighting()).getID(), true, Sighting.class);
                    Sighting workpaceSighting = app.getDBI().findSighting(importSighting.getID(), true, Sighting.class);
                    if (workpaceSighting == null) {
                        // New
                        app.getDBI().createSighting(importSighting, true);
                        importSightingTotal++;
                        inFeedback.println("Imported Observation: " + importSighting.getDisplayName() + " [" + importSighting.getID() + "]");
                    }
                    else {
                        // Update
                        if (!importSighting.hasTheSameContent(workpaceSighting)) {
                            importSightingConflicts++;
                            if (rdbConflictAutoResolve.isSelected()) {
                                if (importSighting.getAuditTime() > workpaceSighting.getAuditTime()) {
                                    app.getDBI().updateSighting(importSighting, true);
                                    importSightingTotal++;
                                    inFeedback.println("Auto Updated Observation: " + importSighting.getDisplayName() + " [" + importSighting.getID() + "]");
                                }
                            }
                            else {
                                WorkspaceImportConflictDialog dialog = new WorkspaceImportConflictDialog(importSighting, workpaceSighting);
                                dialog.setVisible(true);
                                if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.IMPORT) {
                                    app.getDBI().updateSighting(importSighting, true);
                                    importSightingTotal++;
                                    inFeedback.println("Manual Updated Observation: " + importSighting.getDisplayName() + " [" + importSighting.getID() + "]");
                                }
                                else
                                if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.WORKSPACE) {
                                    inFeedback.println("Keep Workspace Observation: " + workpaceSighting.getDisplayName() + " [" + workpaceSighting.getID() + "]");
                                }
                                else {
                                    // Left unresolved, so we fall back to skipping the record
                                    inFeedback.println("Skipped Observation: " + workpaceSighting.getDisplayName() + " [" + workpaceSighting.getID() + "]");
                                }
                            }
                        }
                        saveFiles(importSighting.getWildLogFileID(), inFeedback);
                    }
                }
                inCounter.counter++;
            }
            inProgressbarTask.setTaskProgress(2 + (int)(inCounter.counter/(double)inTotalNodes*97));
            inProgressbarTask.setMessage("Workspace Import: " + inProgressbarTask.getProgress() + "%");
        }
        for (int t = 0; t < treWorkspace.getModel().getChildCount(inNode); t++) {
            DefaultMutableTreeNode childNode = (DefaultMutableTreeNode) treWorkspace.getModel().getChild(inNode, t);
            importRecords(childNode, inTotalNodes, inProgressbarTask, inCounter, inProcessedData, inFeedback);
        }
    }

    private void saveFiles(String inWildLogFileID, PrintWriter inFeedback) {
        // Note: Ek kan WildLogFile.getAbsolutePath() op die import file roep want dit sal relative tot die huidige active workspace wees.
        if (!rdbImportNoFiles.isSelected()) {
            WildLogFileType fileType = null;
            if (rdbImportImagesOnly.isSelected()) {
                fileType = WildLogFileType.IMAGE;
            }
            List<WildLogFile> listExternalFiles = importDBI.listWildLogFiles(inWildLogFileID, fileType, WildLogFile.class);
            for (WildLogFile fileToImport : listExternalFiles) {
                if (app.getDBI().countWildLogFiles(fileToImport.getID(), null) == 0) {
                    // Die file bestaan nie in die workspace nie, kan dus nuut geskep/gecopy word
                    // Don't overwrite existing files
                    if (Files.exists(fileToImport.getAbsolutePath())) {
                        // There is already a file on the disk with the same path, thus we need to rename this one
                        while (Files.exists(fileToImport.getAbsolutePath())) {
                            fileToImport.setDBFilePath(fileToImport.getRelativePath().getParent().resolve("wlimport_" + fileToImport.getRelativePath().getFileName()).toString());
                            WildLogApp.LOGGER.log(Level.INFO, "Renaming importing file to: " + fileToImport.getAbsolutePath().toString());
                        }
                    }
                    // Copy file
                    copyFile(fileToImport);
                    // Save DB entry
                    app.getDBI().createWildLogFile(fileToImport, true);
                    importFileTotal++;
                    inFeedback.println("Imported File: " + fileToImport.getDBFilePath() + " [" + fileToImport.getID() + "]");
                }
                else {
                    importFileConflicts++;
                    try {
                        Path fileToImportFullPath = importWorkspace.resolve(fileToImport.getRelativePath()).toAbsolutePath();
                        // This file is already in the current workspace
                        WildLogFile workpaceFile = app.getDBI().findWildLogFile(fileToImport.getID(), null, null, null, WildLogFile.class);
                        if (rdbConflictAutoResolve.isSelected()) {
                            if (Files.size(fileToImportFullPath) > Files.size(workpaceFile.getAbsolutePath())) {
                                // Copy file
                                copyFile(fileToImport);
                                // Save DB entry
                                app.getDBI().updateWildLogFile(fileToImport, true);
                                importFileTotal++;
                                inFeedback.println("Auto Updated File: " + fileToImport.getDBFilePath() + " [" + fileToImport.getID() + "]");
                            }
                        }
                        else {
                            if (Files.size(fileToImportFullPath) != Files.size(workpaceFile.getAbsolutePath())) {
                                WorkspaceImportConflictDialog dialog = new WorkspaceImportConflictDialog(fileToImportFullPath, workpaceFile.getAbsolutePath());
                                dialog.setVisible(true);
                                if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.IMPORT) {
                                    // Copy file
                                    copyFile(fileToImport);
                                    // Save DB entry
                                    app.getDBI().updateWildLogFile(fileToImport, true);
                                    importFileTotal++;
                                    inFeedback.println("Manual Updated File: " + fileToImport.getDBFilePath() + " [" + fileToImport.getID() + "]");
                                }
                                else
                                if (dialog.getSelectedRecord() == WorkspaceImportConflictDialog.ResolvedRecord.WORKSPACE) {
                                    inFeedback.println("Keep Workspace File: " + workpaceFile.getDBFilePath() + " [" + workpaceFile.getID() + "]");
                                }
                                else {
                                    // Left unresolved, so we fall back to skipping the record
                                    inFeedback.println("Skipped File: " + workpaceFile.getDBFilePath() + " [" + workpaceFile.getID() + "]");
                                }
                            }
                        }
                    }
                    catch (IOException ex) {
                        WildLogApp.LOGGER.log(Level.ERROR, ex.toString(), ex);
                    }
                }
            }
        }
    }

    private void copyFile(WildLogFile fileToImport) {
        // Copy the original file into the workspace
        UtilsFileProcessing.copyFile(
                importWorkspace.resolve(fileToImport.getRelativePath()).toAbsolutePath(),
                fileToImport.getAbsolutePath(), false, true);
        // Resize the file (if the option was selected)
        if (rdbImportThumbnails.isSelected()) {
            UtilsImageProcessing.resizeImage(fileToImport, ((WildLogThumbnailSizes) cmbThumbnailSize.getSelectedItem()).getSize());
        }
        // Create thumbnails
        if (WildLogFileType.IMAGE.equals(fileToImport.getFileType())) {
            fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.VERY_SMALL);
            fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.SMALL);
            fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.MEDIUM_SMALL);
            fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.NORMAL);
        }
    }

    private void rdbImportAllFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportAllFilesActionPerformed
       if (rdbImportAllFiles.isSelected()) {
           rdbImportOriginalImages.setEnabled(true);
           rdbImportThumbnails.setEnabled(true);
       }
    }//GEN-LAST:event_rdbImportAllFilesActionPerformed

    private void rdbImportImagesOnlyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportImagesOnlyActionPerformed
        if (rdbImportImagesOnly.isSelected()) {
           rdbImportOriginalImages.setEnabled(true);
           rdbImportThumbnails.setEnabled(true);
       }
    }//GEN-LAST:event_rdbImportImagesOnlyActionPerformed

    private void rdbImportNoFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportNoFilesActionPerformed
        if (rdbImportNoFiles.isSelected()) {
           rdbImportOriginalImages.setEnabled(false);
           rdbImportThumbnails.setEnabled(false);
       }
    }//GEN-LAST:event_rdbImportNoFilesActionPerformed

    private void treWorkspaceMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_treWorkspaceMousePressed
        // Gebruk die muis se posisie om die node te kry want die LastSelected node is verkeerd, vberal as mens die +/- gebruik om te expand/colapse...
        TreePath clickedPath = treWorkspace.getPathForLocation(evt.getX(), evt.getY());
        if (clickedPath != null && clickedPath.getLastPathComponent() != null) {
            if (((DefaultMutableTreeNode) clickedPath.getLastPathComponent()).getUserObject() instanceof WorkspaceTreeDataWrapper) {
                // Get the selected node and change the isSelected property
                WorkspaceTreeDataWrapper dataWrapper = (WorkspaceTreeDataWrapper) ((DefaultMutableTreeNode) clickedPath.getLastPathComponent()).getUserObject();
                dataWrapper.setIsSelected(!dataWrapper.isSelected());
                // Also update all sub nodes
                if (!evt.isControlDown() || !dataWrapper.isSelected()) {
                    selectChildren((DefaultMutableTreeNode) clickedPath.getLastPathComponent());
                }
                if (dataWrapper.isSelected()) {
                    selectParent((DefaultMutableTreeNode) clickedPath.getLastPathComponent());
                }
            }
            // Need to repaint the tree to make sure all icons are refreshed, otherwise Java does the "smart" thing and and caches painted nodes lower down.
            treWorkspace.repaint();
        }
    }//GEN-LAST:event_treWorkspaceMousePressed

    private void selectChildren(DefaultMutableTreeNode inParentNode) {
        for (int t = 0; t < treWorkspace.getModel().getChildCount(inParentNode); t++) {
            DefaultMutableTreeNode childNode = (DefaultMutableTreeNode) treWorkspace.getModel().getChild(inParentNode, t);
            WorkspaceTreeDataWrapper dataWrapper = (WorkspaceTreeDataWrapper) childNode.getUserObject();
            dataWrapper.setIsSelected(((WorkspaceTreeDataWrapper) inParentNode.getUserObject()).isSelected());
            selectChildren(childNode);
        }
    }

    private void selectParent(DefaultMutableTreeNode inNode) {
        if (((DefaultMutableTreeNode) inNode.getParent()).getUserObject() instanceof WorkspaceTreeDataWrapper) {
            ((WorkspaceTreeDataWrapper) ((DefaultMutableTreeNode) inNode.getParent()).getUserObject()).setIsSelected(
                    ((WorkspaceTreeDataWrapper) inNode.getUserObject()).isSelected());
            selectParent((DefaultMutableTreeNode) inNode.getParent());
        }
    }

    private void rdbOrderByLocationActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbOrderByLocationActionPerformed
        if (rdbOrderByLocation.isSelected()) {
            // Load the tree
            loadLocationTree();
        }
    }//GEN-LAST:event_rdbOrderByLocationActionPerformed

    private void rdbOrderByElementActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbOrderByElementActionPerformed
        if (rdbOrderByElement.isSelected()) {
            loadElementTree();
        }
    }//GEN-LAST:event_rdbOrderByElementActionPerformed

    private void formWindowClosed(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosed
        if (importDBI != null) {
            importDBI.close();
        }
    }//GEN-LAST:event_formWindowClosed

    private void btnCheckConflictsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCheckConflictsActionPerformed
        getGlassPane().setVisible(true);
        getGlassPane().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        int conflicts = 0;
        int totalSelectedNodes = getNumberOfSelectedNodes(treWorkspace.getModel(), (DefaultMutableTreeNode) treWorkspace.getModel().getRoot());
        if (totalSelectedNodes > 0) {
            conflicts = checkConflicts((DefaultMutableTreeNode) treWorkspace.getModel().getRoot(), new HashSet<>());
        }
        getGlassPane().setCursor(Cursor.getDefaultCursor());
        getGlassPane().setVisible(false);
        if (conflicts > 0) {
            WLOptionPane.showMessageDialog(this,
                    "<html>Importing the selected records will result in <b>" + conflicts + " potential conflicts</b>. "
                            + "<br>Conflicts can be resolved during the import process.</html>",
                    "Potential Conflicts Detected!", JOptionPane.WARNING_MESSAGE);
        }
        else {
            WLOptionPane.showMessageDialog(this,
                    "No import conflicts were detected for the selected records.",
                    "No Conflicts Detected", JOptionPane.INFORMATION_MESSAGE);
        }
    }//GEN-LAST:event_btnCheckConflictsActionPerformed

    private void rdbImportOriginalImagesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportOriginalImagesActionPerformed
        if (rdbImportOriginalImages.isSelected()) {
            cmbThumbnailSize.setEnabled(false);
        }
    }//GEN-LAST:event_rdbImportOriginalImagesActionPerformed

    private void rdbImportThumbnailsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportThumbnailsActionPerformed
        if (rdbImportThumbnails.isSelected()) {
            cmbThumbnailSize.setEnabled(true);
        }
    }//GEN-LAST:event_rdbImportThumbnailsActionPerformed

    private int checkConflicts(DefaultMutableTreeNode inNode, Set<String> inProcessedData) {
        int conflict = 0;
        if (inNode.getUserObject() instanceof WorkspaceTreeDataWrapper) {
            WorkspaceTreeDataWrapper dataWrapper = (WorkspaceTreeDataWrapper) inNode.getUserObject();
            if (dataWrapper.isSelected()) {
                // Check the record
                if (dataWrapper.getDataObject() instanceof Location) {
                    if (inProcessedData.add("L" + ((Location) dataWrapper.getDataObject()).getID())) {
                        Location importLocation = importDBI.findLocation(((Location) dataWrapper.getDataObject()).getID(), null, Location.class);
                        Location workspaceLocation = app.getDBI().findLocation(importLocation.getID(), null, Location.class);
                        if (workspaceLocation != null) {
                            if (!importLocation.hasTheSameContent(workspaceLocation)) {
                                conflict = 1;
                            }
                        }
                        conflict = conflict + checkFileConflicts(importLocation.getWildLogFileID());
                    }
                }
                else
                if (dataWrapper.getDataObject() instanceof Visit) {
                    if (inProcessedData.add("V" + ((Visit) dataWrapper.getDataObject()).getID())) {
                        Visit importVisit = importDBI.findVisit(((Visit) dataWrapper.getDataObject()).getID(), null, true, Visit.class);
                        Visit workspaceVisit = app.getDBI().findVisit(importVisit.getID(), null, true, Visit.class);
                        if (workspaceVisit != null) {
                            if (!importVisit.hasTheSameContent(workspaceVisit)) {
                                conflict = 1;
                            }
                        }
                        conflict = conflict + checkFileConflicts(importVisit.getWildLogFileID());
                    }
                }
                else
                if (dataWrapper.getDataObject() instanceof Element) {
                    if (inProcessedData.add("E" + ((Element) dataWrapper.getDataObject()).getID())) {
                        Element importElement = importDBI.findElement(((Element) dataWrapper.getDataObject()).getID(), null, Element.class);
                        Element workspaceElement = app.getDBI().findElement(importElement.getID(), null, Element.class);
                        if (workspaceElement != null) {
                            if (!importElement.hasTheSameContent(workspaceElement)) {
                                conflict = 1;
                            }
                        }
                        conflict = conflict + checkFileConflicts(importElement.getWildLogFileID());
                    }
                }
                else
                if (dataWrapper.getDataObject() instanceof SightingWrapper) {
                    Sighting importSighting = importDBI.findSighting((((SightingWrapper) dataWrapper.getDataObject()).getSighting()).getID(), true, Sighting.class);
                    Sighting workpaceSighting = app.getDBI().findSighting(importSighting.getID(), true, Sighting.class);
                    if (workpaceSighting != null) {
                        if (!importSighting.hasTheSameContent(workpaceSighting)) {
                            conflict = 1;
                        }
                    }
                    conflict = conflict + checkFileConflicts(importSighting.getWildLogFileID());
                }
            }
        }
        for (int t = 0; t < treWorkspace.getModel().getChildCount(inNode); t++) {
            DefaultMutableTreeNode childNode = (DefaultMutableTreeNode) treWorkspace.getModel().getChild(inNode, t);
            conflict = conflict + checkConflicts(childNode, inProcessedData);
        }
        return conflict;
    }
    
    private int checkFileConflicts(String inWildLogFileID) {
        int conflicts = 0;
        if (!rdbImportNoFiles.isSelected()) {
            WildLogFileType fileType = null;
            if (rdbImportImagesOnly.isSelected()) {
                fileType = WildLogFileType.IMAGE;
            }
            List<WildLogFile> listExternalFiles = importDBI.listWildLogFiles(inWildLogFileID, fileType, WildLogFile.class);
            for (WildLogFile fileToImport : listExternalFiles) {
                if (app.getDBI().countWildLogFiles(fileToImport.getID(), null) != 0) {
                    WildLogFile workpaceFile = app.getDBI().findWildLogFile(fileToImport.getID(), null, null, null, WildLogFile.class);
                    try {
                        if (Files.size(importWorkspace.resolve(fileToImport.getRelativePath()).toAbsolutePath()) != Files.size(workpaceFile.getAbsolutePath())) {
                            conflicts++;
                        }
                    }
                    catch (IOException ex) {
                        WildLogApp.LOGGER.log(Level.ERROR, ex.toString(), ex);
                    }
                }
            }
        }
        return conflicts;
    }
    
    private void loadLocationTree() {
        DefaultMutableTreeNode root = new DefaultMutableTreeNode("WildLog Workspace");
        List<Location> locations = new ArrayList<Location>(importDBI.listLocations(null, Location.class));
        Map<Long, DefaultMutableTreeNode> mapElements;
        Map<Long, DefaultMutableTreeNode> mapVisits;
        Collections.sort(locations);
        for (Location location : locations) {
            mapElements = new HashMap<>(500);
            mapVisits = new HashMap<>(500);
            DefaultMutableTreeNode locationNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(location, false));
            root.add(locationNode);
            List<Sighting> sightings = importDBI.listSightings(0, location.getID(), 0, true, Sighting.class);
            Collections.sort(sightings, new Comparator<Sighting>() {
                @Override
                public int compare(Sighting sighting1, Sighting sighting2) {
                    int result = Long.compare(sighting1.getVisitID(), sighting2.getVisitID());
                    if (result == 0) {
                        result = Long.compare(sighting1.getElementID(), sighting2.getElementID());
                        if (result == 0) {
                            result = sighting1.getDate().compareTo(sighting2.getDate());
                        }
                    }
                    return result;
                }
            });
            for (Sighting sighting : sightings) {
                DefaultMutableTreeNode visitNode = mapVisits.get(sighting.getVisitID());
                if (visitNode == null) {
                    visitNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(importDBI.findVisit(sighting.getVisitID(), null, true, Visit.class), false));
                    mapVisits.put(sighting.getVisitID(), visitNode);
                    // Clear die hashmap hier as 'n nuwe visit gelaai word (die sightings behoort volgens visit gesort te wees, so die visit sal nie weer verskyn nie.
                    mapElements.clear();
                }
                locationNode.add(visitNode);
                DefaultMutableTreeNode elementNode = mapElements.get(sighting.getElementID());
                if (elementNode == null) {
                    elementNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(importDBI.findElement(sighting.getElementID(), null, Element.class), false));
                    mapElements.put(sighting.getElementID(), elementNode);
                }
                visitNode.add(elementNode);
                DefaultMutableTreeNode sightingNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(new SightingWrapper(sighting, true), false));
                elementNode.add(sightingNode);
            }
        }
        treWorkspace.setModel(new DefaultTreeModel(root));
    }

    private void loadElementTree() {
        DefaultMutableTreeNode root = new DefaultMutableTreeNode("WildLog Workspace");
        List<Element> elements = new ArrayList<Element>(importDBI.listElements(null, null, null, Element.class));
        Map<Long, DefaultMutableTreeNode> mapLocations;
        Map<Long, DefaultMutableTreeNode> mapVisits;
        Collections.sort(elements);
        for (Element element : elements) {
            mapLocations = new HashMap<>(100);
            mapVisits = new HashMap<>(500);
            DefaultMutableTreeNode elementNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(element, false));
            root.add(elementNode);
            List<Sighting> sightings = importDBI.listSightings(element.getID(), 0, 0, true, Sighting.class);
            Collections.sort(sightings, new Comparator<Sighting>() {
                @Override
                public int compare(Sighting sighting1, Sighting sighting2) {
                    int result = Long.compare(sighting1.getLocationID(), sighting2.getLocationID());
                    if (result == 0) {
                        result = Long.compare(sighting1.getVisitID(), sighting2.getVisitID());
                        if (result == 0) {
                            result = sighting1.getDate().compareTo(sighting2.getDate());
                        }
                    }
                    return result;
                }
            });
            for (Sighting sighting : sightings) {
                DefaultMutableTreeNode locationNode = mapLocations.get(sighting.getLocationID());
                if (locationNode == null) {
                    locationNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(importDBI.findLocation(sighting.getLocationID(), null, Location.class), false));
                    mapLocations.put(sighting.getLocationID(), locationNode);
                }
                elementNode.add(locationNode);
                DefaultMutableTreeNode visitNode = mapVisits.get(sighting.getVisitID());
                if (visitNode == null) {
                    visitNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(importDBI.findVisit(sighting.getVisitID(), null, true, Visit.class), false));
                    mapVisits.put(sighting.getVisitID(), visitNode);
                }
                locationNode.add(visitNode);
                DefaultMutableTreeNode sightingNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(new SightingWrapper(sighting, true), false));
                visitNode.add(sightingNode);
            }
        }
        treWorkspace.setModel(new DefaultTreeModel(root));
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnCheckConflicts;
    private javax.swing.JButton btnConfirm;
    private javax.swing.JComboBox<WildLogThumbnailSizes> cmbThumbnailSize;
    private javax.swing.ButtonGroup grpConflicts;
    private javax.swing.ButtonGroup grpFiles;
    private javax.swing.ButtonGroup grpImages;
    private javax.swing.ButtonGroup grpTreeOrder;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JSeparator jSeparator3;
    private javax.swing.JRadioButton rdbConflictAsk;
    private javax.swing.JRadioButton rdbConflictAutoResolve;
    private javax.swing.JRadioButton rdbImportAllFiles;
    private javax.swing.JRadioButton rdbImportImagesOnly;
    private javax.swing.JRadioButton rdbImportNoFiles;
    private javax.swing.JRadioButton rdbImportOriginalImages;
    private javax.swing.JRadioButton rdbImportThumbnails;
    private javax.swing.JRadioButton rdbOrderByElement;
    private javax.swing.JRadioButton rdbOrderByLocation;
    private javax.swing.JTree treWorkspace;
    // End of variables declaration//GEN-END:variables
}
