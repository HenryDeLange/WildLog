package wildlog.ui.dialogs;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.KeyAdapter;
import java.awt.event.MouseAdapter;
import java.io.BufferedReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.Reader;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.DefaultComboBoxModel;
import javax.swing.ImageIcon;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.LineBorder;
import org.apache.logging.log4j.Level;
import org.netbeans.lib.awtextra.AbsoluteConstraints;
import org.netbeans.lib.awtextra.AbsoluteLayout;
import wildlog.WildLogApp;
import wildlog.WildLogView;
import wildlog.data.dataobjects.Element;
import wildlog.data.dataobjects.ElementCore;
import wildlog.data.dataobjects.Location;
import wildlog.data.dataobjects.LocationCore;
import wildlog.data.dataobjects.Sighting;
import wildlog.data.dataobjects.SightingCore;
import wildlog.data.dataobjects.Visit;
import wildlog.data.dataobjects.VisitCore;
import wildlog.data.dataobjects.WildLogDeleteLog;
import wildlog.data.dataobjects.WildLogUser;
import wildlog.data.dataobjects.interfaces.DataObjectWithAudit;
import wildlog.data.enums.WildLogDataType;
import wildlog.data.enums.WildLogThumbnailSizes;
import wildlog.encryption.TokenEncryptor;
import wildlog.sync.azure.UtilsSync;
import wildlog.sync.azure.dataobjects.SyncTableEntry;
import wildlog.ui.dialogs.utils.UtilsDialog;
import wildlog.ui.helpers.ProgressbarTask;
import wildlog.ui.helpers.WLOptionPane;
import wildlog.utils.UtilsConcurency;
import wildlog.utils.UtilsFileProcessing;
import wildlog.utils.WildLogPaths;


public class WorkspaceSyncDialog extends JDialog {
    private int syncDeleteUp = 0;
    private int syncDeleteDown = 0;
    private int syncDataUp = 0;
    private int syncDataDown = 0;
    private int syncFileUp = 0;
    private int syncFileDown = 0;
    private int syncFail = 0;


    public WorkspaceSyncDialog() {
        super();
        WildLogApp.LOGGER.log(Level.INFO, "[WorkspaceSyncDialog]");
        initComponents();
        // Setup the default behavior
        UtilsDialog.setDialogToCenter(WildLogApp.getApplication().getMainFrame(), this);
        UtilsDialog.addEscapeKeyListener(this);
        // Setup the glasspane on this dialog as well for the JOptionPane's
        UtilsDialog.addModalBackgroundPanel(WildLogApp.getApplication().getMainFrame(), this);
        UtilsDialog.addModalBackgroundPanel(this, null);
        // Default to the free token's configuration
        configureFreeToken();
    }
    
    private void configureFreeToken() {
        rdbModeBatch.setSelected(true);
        rdbModeSingle.setEnabled(false);
        rdbImportThumbnails.setSelected(true);
        rdbImportThumbnails.setEnabled(false);
        rdbImportOriginalImages.setEnabled(false);
        cmbThumbnailSize.setEnabled(false);
        rdbImportNoFiles.setSelected(true);
        rdbImportAllFiles.setEnabled(false);
        rdbImportImagesOnly.setEnabled(false);
    }
    
    private void configureBasicToken() {
        rdbModeBatch.setSelected(true);
        rdbModeSingle.setEnabled(true);
        rdbImportThumbnails.setSelected(true);
        rdbImportThumbnails.setEnabled(true);
        rdbImportOriginalImages.setEnabled(false);
        cmbThumbnailSize.setEnabled(true);
        rdbImportImagesOnly.setSelected(true);
        rdbImportAllFiles.setEnabled(false);
        rdbImportImagesOnly.setEnabled(true);
    }
    
    private void configureFullToken() {
        rdbModeBatch.setSelected(true);
        rdbModeSingle.setEnabled(true);
        rdbImportOriginalImages.setSelected(true);
        rdbImportThumbnails.setEnabled(true);
        rdbImportOriginalImages.setEnabled(true);
        cmbThumbnailSize.setEnabled(true);
        rdbImportAllFiles.setSelected(true);
        rdbImportAllFiles.setEnabled(true);
        rdbImportImagesOnly.setEnabled(true);
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        grpFiles = new javax.swing.ButtonGroup();
        grpImages = new javax.swing.ButtonGroup();
        grpMode = new javax.swing.ButtonGroup();
        grpConflicts = new javax.swing.ButtonGroup();
        jLabel4 = new javax.swing.JLabel();
        btnConfirm = new javax.swing.JButton();
        pnlSyncToken = new javax.swing.JPanel();
        jLabel6 = new javax.swing.JLabel();
        jSeparator4 = new javax.swing.JSeparator();
        jLabel3 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        txaSyncToken = new javax.swing.JTextArea();
        btnConfirmSyncToken = new javax.swing.JButton();
        pnlSyncOptions = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        rdbImportAllFiles = new javax.swing.JRadioButton();
        rdbImportImagesOnly = new javax.swing.JRadioButton();
        rdbImportNoFiles = new javax.swing.JRadioButton();
        jSeparator1 = new javax.swing.JSeparator();
        rdbImportOriginalImages = new javax.swing.JRadioButton();
        rdbImportThumbnails = new javax.swing.JRadioButton();
        cmbThumbnailSize = new javax.swing.JComboBox<>();
        jLabel7 = new javax.swing.JLabel();
        jSeparator3 = new javax.swing.JSeparator();
        jLabel1 = new javax.swing.JLabel();
        rdbModeBatch = new javax.swing.JRadioButton();
        rdbModeSingle = new javax.swing.JRadioButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Cloud Sync Workspace");
        setIconImage(new ImageIcon(WildLogApp.class.getResource("resources/icons/Sync.png")).getImage());
        setModal(true);
        setResizable(false);

        jLabel4.setFont(new java.awt.Font("Tahoma", 1, 24)); // NOI18N
        jLabel4.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel4.setText("Cloud Sync Workspace");

        btnConfirm.setIcon(new javax.swing.ImageIcon(getClass().getResource("/wildlog/resources/icons/OK.png"))); // NOI18N
        btnConfirm.setToolTipText("Sync the active Workspace with the data stored in the cloud.");
        btnConfirm.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnConfirm.setFocusPainted(false);
        btnConfirm.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnConfirmActionPerformed(evt);
            }
        });

        pnlSyncToken.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Sync Token", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 1, 14))); // NOI18N

        jLabel6.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        jLabel6.setText("<html><b>Please provide your <i>WildLog Cloud Sync Token</i> to enable WildLog to synchronise the data.</b> <br/><br/> If you don't have a <i>WildLog Cloud Sync Token</i> then please contact <u>support@mywild.co.za</> for a custom quotation. <br/><br/> Alternatively, you can use the limited free token by simply leaving the <i>WildLog Cloud Sync Token</i> field empty.</html>");

        jLabel3.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel3.setText("Sync Token:");

        txaSyncToken.setFont(new java.awt.Font("Monospaced", 0, 11)); // NOI18N
        txaSyncToken.setLineWrap(true);
        txaSyncToken.setWrapStyleWord(true);
        jScrollPane1.setViewportView(txaSyncToken);

        btnConfirmSyncToken.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        btnConfirmSyncToken.setText("Confirm Token");
        btnConfirmSyncToken.setToolTipText("Validates the token and then enables the available features.");
        btnConfirmSyncToken.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnConfirmSyncToken.setFocusPainted(false);
        btnConfirmSyncToken.setMargin(new java.awt.Insets(2, 2, 2, 2));
        btnConfirmSyncToken.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnConfirmSyncTokenActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout pnlSyncTokenLayout = new javax.swing.GroupLayout(pnlSyncToken);
        pnlSyncToken.setLayout(pnlSyncTokenLayout);
        pnlSyncTokenLayout.setHorizontalGroup(
            pnlSyncTokenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnlSyncTokenLayout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addGroup(pnlSyncTokenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jScrollPane1)
                    .addComponent(btnConfirmSyncToken, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, pnlSyncTokenLayout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(jLabel6)
                    .addComponent(jSeparator4))
                .addGap(5, 5, 5))
        );
        pnlSyncTokenLayout.setVerticalGroup(
            pnlSyncTokenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlSyncTokenLayout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addComponent(jLabel6)
                .addGap(10, 10, 10)
                .addComponent(jSeparator4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(3, 3, 3)
                .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(3, 3, 3)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 90, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(3, 3, 3)
                .addComponent(btnConfirmSyncToken, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(5, 5, 5))
        );

        pnlSyncOptions.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Sync Options", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 1, 14))); // NOI18N

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel2.setText("Files:");

        grpFiles.add(rdbImportAllFiles);
        rdbImportAllFiles.setText("All Files");
        rdbImportAllFiles.setToolTipText("Sync all files between the current Workspace and the cloud.");
        rdbImportAllFiles.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportAllFiles.setFocusPainted(false);
        rdbImportAllFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportAllFilesActionPerformed(evt);
            }
        });

        grpFiles.add(rdbImportImagesOnly);
        rdbImportImagesOnly.setText("Images Only");
        rdbImportImagesOnly.setToolTipText("Sync only images between the current Workspace and the cloud.");
        rdbImportImagesOnly.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportImagesOnly.setFocusPainted(false);
        rdbImportImagesOnly.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportImagesOnlyActionPerformed(evt);
            }
        });

        grpFiles.add(rdbImportNoFiles);
        rdbImportNoFiles.setSelected(true);
        rdbImportNoFiles.setText("No Files");
        rdbImportNoFiles.setToolTipText("Don't sync any files between the current Workspace and the cloud.");
        rdbImportNoFiles.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportNoFiles.setFocusPainted(false);
        rdbImportNoFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportNoFilesActionPerformed(evt);
            }
        });

        jSeparator1.setOrientation(javax.swing.SwingConstants.VERTICAL);

        grpImages.add(rdbImportOriginalImages);
        rdbImportOriginalImages.setText("Original Images");
        rdbImportOriginalImages.setToolTipText("Sync a copy of the original linked images between the current Workspace and the cloud.");
        rdbImportOriginalImages.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportOriginalImages.setFocusPainted(false);
        rdbImportOriginalImages.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportOriginalImagesActionPerformed(evt);
            }
        });

        grpImages.add(rdbImportThumbnails);
        rdbImportThumbnails.setSelected(true);
        rdbImportThumbnails.setText("Thumbnail Images");
        rdbImportThumbnails.setToolTipText("The images that are synced will be reduced in size, the original images will not be synced.");
        rdbImportThumbnails.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportThumbnails.setFocusPainted(false);
        rdbImportThumbnails.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportThumbnailsActionPerformed(evt);
            }
        });

        cmbThumbnailSize.setMaximumRowCount(15);
        cmbThumbnailSize.setModel(new DefaultComboBoxModel(WildLogThumbnailSizes.values()));
        cmbThumbnailSize.setSelectedItem(WildLogThumbnailSizes.VERY_LARGE);
        cmbThumbnailSize.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        cmbThumbnailSize.setEnabled(false);
        cmbThumbnailSize.setFocusable(false);

        jLabel7.setText("px");

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel1.setText("Mode:");

        grpMode.add(rdbModeBatch);
        rdbModeBatch.setSelected(true);
        rdbModeBatch.setText("Batch Mode");
        rdbModeBatch.setToolTipText("Perform the sync using batch operations.");
        rdbModeBatch.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbModeBatch.setFocusPainted(false);

        grpMode.add(rdbModeSingle);
        rdbModeSingle.setText("Single Mode");
        rdbModeSingle.setToolTipText("Perform the sync using single operations for each record.");
        rdbModeSingle.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbModeSingle.setFocusPainted(false);

        javax.swing.GroupLayout pnlSyncOptionsLayout = new javax.swing.GroupLayout(pnlSyncOptions);
        pnlSyncOptions.setLayout(pnlSyncOptionsLayout);
        pnlSyncOptionsLayout.setHorizontalGroup(
            pnlSyncOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlSyncOptionsLayout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addGroup(pnlSyncOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnlSyncOptionsLayout.createSequentialGroup()
                        .addComponent(jSeparator3)
                        .addGap(11, 11, 11))
                    .addGroup(pnlSyncOptionsLayout.createSequentialGroup()
                        .addGroup(pnlSyncOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(pnlSyncOptionsLayout.createSequentialGroup()
                                .addGap(1, 1, 1)
                                .addComponent(jLabel1)
                                .addGap(10, 10, 10)
                                .addComponent(rdbModeBatch)
                                .addGap(5, 5, 5)
                                .addComponent(rdbModeSingle))
                            .addGroup(pnlSyncOptionsLayout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addGap(10, 10, 10)
                                .addComponent(rdbImportAllFiles)
                                .addGap(5, 5, 5)
                                .addComponent(rdbImportImagesOnly)
                                .addGap(5, 5, 5)
                                .addComponent(rdbImportNoFiles)
                                .addGap(10, 10, 10)
                                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(10, 10, 10)
                                .addComponent(rdbImportOriginalImages)
                                .addGap(5, 5, 5)
                                .addComponent(rdbImportThumbnails)
                                .addGap(5, 5, 5)
                                .addComponent(cmbThumbnailSize, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(5, 5, 5)
                                .addComponent(jLabel7)))
                        .addContainerGap())))
        );
        pnlSyncOptionsLayout.setVerticalGroup(
            pnlSyncOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlSyncOptionsLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pnlSyncOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jSeparator1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(pnlSyncOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                        .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, pnlSyncOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel7)
                            .addComponent(cmbThumbnailSize, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, pnlSyncOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(rdbImportOriginalImages)
                            .addComponent(rdbImportThumbnails)
                            .addComponent(rdbImportImagesOnly)
                            .addComponent(rdbImportAllFiles)
                            .addComponent(rdbImportNoFiles))))
                .addGap(5, 5, 5)
                .addComponent(jSeparator3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(5, 5, 5)
                .addGroup(pnlSyncOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(rdbModeBatch)
                    .addComponent(rdbModeSingle))
                .addGap(5, 5, 5))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(5, 5, 5))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(pnlSyncToken, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(10, 10, 10)))
                .addComponent(btnConfirm, javax.swing.GroupLayout.PREFERRED_SIZE, 110, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(10, 10, 10))
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(pnlSyncOptions, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(130, 130, 130))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(btnConfirm, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel4)
                        .addGap(10, 10, 10)
                        .addComponent(pnlSyncToken, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(10, 10, 10)
                .addComponent(pnlSyncOptions, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(10, 10, 10))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnConfirmActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnConfirmActionPerformed
        WildLogApp.LOGGER.log(Level.INFO, "[SyncWorkspace]");
        // Get the sync keys from the token
        String syncToken;
        if (txaSyncToken.getText() == null || txaSyncToken.getText().isEmpty()) {
            final char[] buffer = new char[450];
            final StringBuilder builder = new StringBuilder(450);
            try (Reader in = new BufferedReader(new InputStreamReader(WildLogApp.class.getResourceAsStream("sync/FreeSyncToken"), "UTF-8"))) {
                int length = 0;
                while (length >= 0) {
                    length = in.read(buffer, 0, buffer.length);
                    if (length > 0) {
                        builder.append(buffer, 0, length);
                    }
                }
            }
            catch (IOException ex) {
                WildLogApp.LOGGER.log(Level.ERROR, ex.toString(), ex);
            }
            syncToken = TokenEncryptor.decrypt(builder.toString());
        }
        else {
            syncToken = TokenEncryptor.decrypt(txaSyncToken.getText());
        }
        // Validate the token
        if (syncToken == null || syncToken.isEmpty() || syncToken.split(" ").length != 4) {
            WLOptionPane.showMessageDialog(this,
                    "<html>The provided <i>WildLog Cloud Sync Token</i> could not be read. "
                            + "<br>Please provide a valid <i>WildLog Cloud Sync Token</i>, or contact <u>support@mywild.co.za</> for help.</html>",
                    "Invalid Sync Token!", JOptionPane.ERROR_MESSAGE);
            return;
        }
        // Parse the token to get the necessary values
        String[] syncTokenValues = syncToken.split(" ");
        WildLogApp.LOGGER.log(Level.INFO, "Sync Mode: {}", syncTokenValues[0]);
        if (syncTokenValues[0].equals("FREE")) {
            WLOptionPane.showMessageDialog(this,
                    "<html>You are currently using the limited free <i>WildLog Cloud Sync Token</i>. "
                            + "<br>This token can only be used with 1000 or less records and files are not synced."
                            + "<br>The token is subject to fair use and load restrictions."
                            + "<br>Contact <u>support@mywild.co.za</> for more details.</html>",
                    "Using Free Sync Token", JOptionPane.WARNING_MESSAGE);
            if ((WildLogApp.getApplication().getDBI().countDeleteLogs(null) 
                    + WildLogApp.getApplication().getDBI().countElements(null, null)
                    + WildLogApp.getApplication().getDBI().countLocations(null)
                    + WildLogApp.getApplication().getDBI().countSightings(0, 0, 0, 0)
                    + WildLogApp.getApplication().getDBI().countUsers()
                    + WildLogApp.getApplication().getDBI().countVisits(null, 0)) > 1000) {
                WLOptionPane.showMessageDialog(this,
                    "<html>This WildLog Workspace exceeds the restrictions of the limted free <i>WildLog Cloud Sync Token</i>. "
                            + "<br>Please contact <u>support@mywild.co.za</> for help.</html>",
                    "Free Token Exceeded!", JOptionPane.ERROR_MESSAGE);
                return;
            }
        }
        String syncAccount = syncTokenValues[1];
        String syncKey = syncTokenValues[2];
        String syncConnection = syncTokenValues[3];
        long workspaceID = WildLogApp.getApplication().getWildLogOptions().getWorkspaceID();
        int dbVersion = WildLogApp.getApplication().getWildLogOptions().getDatabaseVersion();
        // Close this popup
        setVisible(false);
        dispose();
        // Start the sync process
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                // Close all tabs and go to the home tab
                WildLogApp.getApplication().getMainFrame().getTabbedPane().setSelectedIndex(0);
                while (WildLogApp.getApplication().getMainFrame().getTabbedPane().getTabCount() > WildLogView.STATIC_TAB_COUNT) {
                    WildLogApp.getApplication().getMainFrame().getTabbedPane().remove(WildLogView.STATIC_TAB_COUNT);
                }
                // Lock the input/display and show busy message
                // Note: we never remove the Busy dialog and greyed out background since the app will be restarted anyway when done (Don't use JDialog since it stops the code until the dialog is closed...)
                WildLogApp.getApplication().getMainFrame().getTabbedPane().setSelectedIndex(0);
                SwingUtilities.invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        JPanel panel = new JPanel(new AbsoluteLayout());
                        panel.setPreferredSize(new Dimension(400, 50));
                        panel.setBorder(new LineBorder(new Color(245, 80, 40), 3));
                        JLabel label = new JLabel("<html>Busy with Cloud Sync Workspace. Please be patient, this might take a while. <br/>"
                                + "Don't close the application until the process is finished.</html>");
                        label.setFont(new Font("Tahoma", Font.BOLD, 12));
                        label.setBorder(new LineBorder(new Color(195, 65, 20), 4));
                        panel.setBackground(new Color(0.22f, 0.26f, 0.20f, 0.95f));
                        panel.add(label, new AbsoluteConstraints(410, 20, -1, -1));
                        panel.setBackground(new Color(0.22f, 0.26f, 0.20f, 0.25f));
                        JPanel glassPane = (JPanel) WildLogApp.getApplication().getMainFrame().getGlassPane();
                        glassPane.removeAll();
                        glassPane.setLayout(new BorderLayout(100, 100));
                        glassPane.add(panel, BorderLayout.CENTER);
                        glassPane.addMouseListener(new MouseAdapter() {});
                        glassPane.addKeyListener(new KeyAdapter() {});
                        WildLogApp.getApplication().getMainFrame().setGlassPane(glassPane);
                        WildLogApp.getApplication().getMainFrame().getGlassPane().setVisible(true);
                        WildLogApp.getApplication().getMainFrame().getGlassPane().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
                    }
                });
                UtilsConcurency.kickoffProgressbarTask(WildLogApp.getApplication(), new ProgressbarTask(WildLogApp.getApplication()) {
                    
                    
// TODO: Sit later die progressbar by
                    
                    
                    @Override
                    protected Object doInBackground() throws Exception {
                        long startTime = System.currentTimeMillis();
                        setProgress(0);
                        setMessage("Starting the Cloud Sync Workspace");
                        setProgress(1);
                        setMessage("Busy with the Cloud Sync Workspace " + getProgress() + "%");
                        // Setup the report
                        Path feedbackFile = WildLogPaths.getFullWorkspacePrefix().resolve("CloudSyncWorkspaceReport.txt");
                        PrintWriter feedback = null;
                        try {
                            feedback = new PrintWriter(new FileWriter(feedbackFile.toFile()), true);
                            feedback.println("-------------------------------------------------");
                            feedback.println("---------- Cloud Sync Workspace Report ----------");
                            feedback.println("-------------------------------------------------");
                            feedback.println("");
                            // SYNC - Delete Logs
                            syncDeleteLogs(feedback, syncConnection, workspaceID, dbVersion);
                            // SYNC - Data
                            syncDataRecords(feedback, syncConnection, workspaceID, dbVersion, WildLogDataType.ELEMENT);
                            syncDataRecords(feedback, syncConnection, workspaceID, dbVersion, WildLogDataType.LOCATION);
                            syncDataRecords(feedback, syncConnection, workspaceID, dbVersion, WildLogDataType.VISIT);
                            syncDataRecords(feedback, syncConnection, workspaceID, dbVersion, WildLogDataType.SIGHTING);
                            syncDataRecords(feedback, syncConnection, workspaceID, dbVersion, WildLogDataType.WILDLOG_USER);
                            // SYNC - Files
// TODO: Files
                        }
                        // Finish the report
                        catch (Exception ex) {
                            if (feedback != null) {
                                feedback.println("");
                                feedback.println("--------------------------------------");
                                feedback.println("--------------- ERROR ----------------");
                                feedback.println(ex.toString());
                                feedback.println("--------------------------------------");
                                feedback.println("");
                            }
                            syncFail++;
                            throw ex;
                        }
                        finally {
                            if (feedback != null) {
                                feedback.println("");
                                feedback.println("--------------- SUMMARY ----------------");
                                feedback.println("Failed Sync Actions        : " + syncFail);
                                feedback.println("Synced DeleteLog Uploads   : " + syncDeleteUp);
                                feedback.println("Synced DeleteLog Downloads : " + syncDeleteDown);
                                feedback.println("Synced Data Uploads        : " + syncDataUp);
                                feedback.println("Synced Data Downloads      : " + syncDataDown);
                                feedback.println("Synced File Uploads        : " + syncFileUp);
                                feedback.println("Synced File Downloads      : " + syncFileDown);
                                feedback.println("");
                                feedback.println("--------------- DURATION ----------------");
                                long duration = System.currentTimeMillis() - startTime;
                                int hours = (int) (((double) duration)/(1000.0*60.0*60.0));
                                int minutes = (int) (((double) duration - (hours*60*60*1000))/(1000.0*60.0));
                                int seconds = (int) (((double) duration - (hours*60*60*1000) - (minutes*60*1000))/(1000.0));
                                feedback.println(hours + " hours, " + minutes + " minutes, " + seconds + " seconds");
                                WildLogApp.LOGGER.log(Level.INFO, "Cloud Sync Duration: {} hours, {} minutes, {} seconds", hours, minutes, seconds);
                                feedback.println("");
                                feedback.println("--------------------------------------");
                                feedback.println("-------------- FINISHED --------------");
                                feedback.println("--------------------------------------");
                                feedback.println("");
                                feedback.flush();
                                feedback.close();
                                // Open the summary document
                                UtilsFileProcessing.openFile(feedbackFile);
                            }
                        }
                        setProgress(100);
                        setMessage("Done with the Cloud Sync Workspace");
                        return null;
                    }

                    @Override
                    protected void finished() {
                        super.finished();
                        // Using invokeLater because I hope the progressbar will have finished by then, otherwise the popup is shown
                        // that asks whether you want to close the application or not, and it's best to rather restart after the cleanup.
                        SwingUtilities.invokeLater(new Runnable() {
                            @Override
                            public void run() {
                                // Close the application to be safe (make sure no wierd references/paths are still used, etc.)
                                WLOptionPane.showMessageDialog(null, 
                                        "The Cloud Sync Workspace process has completed. Please restart the application.", 
                                        "Completed Cloud Sync Workspace", WLOptionPane.INFORMATION_MESSAGE);
                                WildLogApp.getApplication().quit(null);
                            }
                        });
                    }
                });
            }
        });
    }//GEN-LAST:event_btnConfirmActionPerformed

    private void rdbImportAllFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportAllFilesActionPerformed
       if (rdbImportAllFiles.isSelected()) {
           rdbImportOriginalImages.setEnabled(true);
           rdbImportThumbnails.setEnabled(true);
       }
    }//GEN-LAST:event_rdbImportAllFilesActionPerformed

    private void rdbImportImagesOnlyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportImagesOnlyActionPerformed
        if (rdbImportImagesOnly.isSelected()) {
           rdbImportOriginalImages.setEnabled(true);
           rdbImportThumbnails.setEnabled(true);
       }
    }//GEN-LAST:event_rdbImportImagesOnlyActionPerformed

    private void rdbImportNoFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportNoFilesActionPerformed
        if (rdbImportNoFiles.isSelected()) {
           rdbImportOriginalImages.setEnabled(false);
           rdbImportThumbnails.setEnabled(false);
       }
    }//GEN-LAST:event_rdbImportNoFilesActionPerformed

    private void rdbImportOriginalImagesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportOriginalImagesActionPerformed
        if (rdbImportOriginalImages.isSelected()) {
            cmbThumbnailSize.setEnabled(false);
        }
    }//GEN-LAST:event_rdbImportOriginalImagesActionPerformed

    private void rdbImportThumbnailsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportThumbnailsActionPerformed
        if (rdbImportThumbnails.isSelected()) {
            cmbThumbnailSize.setEnabled(true);
        }
    }//GEN-LAST:event_rdbImportThumbnailsActionPerformed

    private void btnConfirmSyncTokenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnConfirmSyncTokenActionPerformed
        if (txaSyncToken.getText() == null || txaSyncToken.getText().isEmpty()) {
            configureFreeToken();
        }
        else {
            String syncToken = TokenEncryptor.decrypt(txaSyncToken.getText());
            if (syncToken == null || syncToken.isEmpty()) {
                WLOptionPane.showMessageDialog(this,
                        "<html>The provided <i>WildLog Cloud Sync Token</i> could not be read. "
                                + "<br>Please provide a valid <i>WildLog Cloud Sync Token</i>, or contact <u>support@mywild.co.za</> for help.</html>",
                        "Invalid Sync Token!", JOptionPane.ERROR_MESSAGE);
            }
            String[] syncTokenValues = syncToken.split(" ");
            switch (syncTokenValues[0]) {
                case "FREE": configureFreeToken(); break;
                case "BASIC": configureBasicToken(); break;
                case "FULL": configureFullToken(); break;
                default: configureFreeToken(); break;
            }
        }
    }//GEN-LAST:event_btnConfirmSyncTokenActionPerformed

    private void logIfFailed(PrintWriter inFeedback, SyncAction inSyncAction, boolean inResult) {
        if (inResult) {
            inFeedback.println(inSyncAction.command + " " + inSyncAction.type.getDescription() + " " + inSyncAction.recordID + " " + inSyncAction.details);
        }
        else {
            inFeedback.println("SYNC_FAIL " + inSyncAction.command + " " + inSyncAction.type.getDescription() + " " + inSyncAction.recordID + " " + inSyncAction.details);
            WildLogApp.LOGGER.log(Level.ERROR, "Sync - Failed: " + inSyncAction.command + " " + inSyncAction.type.getDescription() + " " + inSyncAction.recordID + " " + inSyncAction.details + " " + inSyncAction.data);
            WildLogApp.LOGGER.log(Level.INFO, "Sync - Stacktrace:");
            new Exception().printStackTrace(System.out);
            syncFail++;
        }
    }
    
    private void syncDeleteLogs(PrintWriter inFeedback, String inSyncConnection, long inWorkspaceID, int inDBVersion) {
        List<SyncTableEntry> lstCloudEntries  = UtilsSync.getSyncListDataBatch(inSyncConnection, WildLogDataType.DELETE_LOG, inWorkspaceID);
        WildLogApp.LOGGER.log(Level.INFO, "Sync - Delete Logs - Cloud Entries: " + lstCloudEntries.size());
        List<WildLogDeleteLog> lstWorkspaceEntries = WildLogApp.getApplication().getDBI().listDeleteLogs(null, 0, WildLogDeleteLog.class);
        WildLogApp.LOGGER.log(Level.INFO, "Sync - Delete Logs - Workspace Entries: " + lstCloudEntries.size());
        // UP: Make sure cloud knows about new workspace records
        Map<WildLogDataType, List<SyncAction>> mapActions = new HashMap<>();
        for (WildLogDeleteLog workspaceEntry : lstWorkspaceEntries) {
            boolean found = false;
            for (SyncTableEntry cloudEntry : lstCloudEntries) {
                if (workspaceEntry.getID() == cloudEntry.getRecordID()) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                List<SyncAction> lstSyncActions = mapActions.get(workspaceEntry.getType());
                if(lstSyncActions == null) {
                    lstSyncActions = new ArrayList<>();
                    mapActions.put(workspaceEntry.getType(), lstSyncActions);
                }
                lstSyncActions.add(new SyncAction("", workspaceEntry.getType(), workspaceEntry.getID(), "", workspaceEntry));
            }
        }
        List<WildLogDataType> lstKeys = new ArrayList<>(mapActions.keySet());
        Collections.sort(lstKeys);
        for (WildLogDataType dataType : lstKeys) {
            if (rdbModeBatch.isSelected()) {
                List<SyncAction> lstSyncActions = mapActions.get(dataType);
                if (!lstSyncActions.isEmpty()) {
                    List<DataObjectWithAudit> lstRecords = new ArrayList<>(lstSyncActions.size());
                    List<Long> lstRecordIDs = new ArrayList<>(lstSyncActions.size());
                    for (SyncAction syncAction : lstSyncActions) {
                        lstRecords.add(syncAction.data);
                        lstRecordIDs.add(syncAction.recordID);
                    }
                    logIfFailed(inFeedback, new SyncAction("CLOUD_UPLOAD " + WildLogDataType.DELETE_LOG.getDescription() + " ", 
                            dataType, lstRecords.size(), Arrays.toString(lstRecords.toArray()), null), 
                            UtilsSync.uploadDataBatch(inSyncConnection, WildLogDataType.DELETE_LOG, inWorkspaceID, inDBVersion, lstRecords));
                    logIfFailed(inFeedback, new SyncAction("CLOUD_DELETE", 
                            dataType, lstRecordIDs.size(), Arrays.toString(lstRecordIDs.toArray()), null),
                            UtilsSync.deleteDataBatch(inSyncConnection, dataType, inWorkspaceID, lstRecordIDs));
                    syncDeleteUp = syncDeleteUp + lstRecordIDs.size();
                }
            }
            else {
                for (SyncAction syncAction : mapActions.get(dataType)) {
                    syncAction.command = "CLOUD_UPLOAD" + WildLogDataType.DELETE_LOG.getDescription() + " ";
                    logIfFailed(inFeedback, syncAction, UtilsSync.uploadData(inSyncConnection, WildLogDataType.DELETE_LOG, inWorkspaceID, inDBVersion, syncAction.data));
                    syncAction.command = "CLOUD_DELETE";
                    logIfFailed(inFeedback, syncAction, UtilsSync.deleteData(inSyncConnection, dataType, inWorkspaceID, syncAction.recordID));
                    syncDeleteUp++;
                }
            }
        }
        // DOWN: Make sure the workspace knows about new cloud records
        for (SyncTableEntry cloudEntry : lstCloudEntries) {
            boolean found = false;
            for (WildLogDeleteLog workspaceEntry : lstWorkspaceEntries) {
                if (workspaceEntry.getID() == cloudEntry.getRecordID()) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                SyncAction syncAction = new SyncAction("WORKSPACE_DOWNLOAD", WildLogDataType.DELETE_LOG, 
                        cloudEntry.getRecordID(), "[" + cloudEntry.getWildLogDataType() + "]", null);
                logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().createDeleteLog(
                        new WildLogDeleteLog(cloudEntry.getWildLogDataType(), cloudEntry.getRecordID())));
                syncAction.command = "WORKSPACE_DELETE" + WildLogDataType.DELETE_LOG.getDescription() + " ";
                syncAction.type = cloudEntry.getWildLogDataType();
                if(cloudEntry.getWildLogDataType() == WildLogDataType.ELEMENT) {
                    logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().deleteElement(syncAction.recordID));
                }
                else
                if(cloudEntry.getWildLogDataType() == WildLogDataType.LOCATION) {
                    logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().deleteLocation(syncAction.recordID));
                }
                else
                if(cloudEntry.getWildLogDataType() == WildLogDataType.VISIT) {
                    logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().deleteVisit(syncAction.recordID));
                }
                else
                if(cloudEntry.getWildLogDataType() == WildLogDataType.SIGHTING) {
                    logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().deleteSighting(syncAction.recordID));
                }
                else
                if(cloudEntry.getWildLogDataType() == WildLogDataType.WILDLOG_USER) {
                    logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().deleteUser(syncAction.recordID));
                }
                else
                if(cloudEntry.getWildLogDataType() == WildLogDataType.FILE) {
                    logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().deleteWildLogFile(syncAction.recordID));
                }
                else {
                    logIfFailed(inFeedback, syncAction, false);
                }
                syncDeleteDown++;
            }
        }
    }
    
    private void syncDataRecords(PrintWriter inFeedback, String inSyncConnection, long inWorkspaceID, int inDBVersion, WildLogDataType inDataType) {
        List<SyncTableEntry> lstCloudEntries  = UtilsSync.getSyncListDataBatch(inSyncConnection, inDataType, inWorkspaceID);
        WildLogApp.LOGGER.log(Level.INFO, "Sync - " + inDataType.getDescription() + " - Cloud Entries: " + lstCloudEntries.size());
        List<? extends DataObjectWithAudit> lstWorkspaceEntries;
        if(inDataType == WildLogDataType.ELEMENT) {
            lstWorkspaceEntries = WildLogApp.getApplication().getDBI().listElements(null, null, null, Element.class);
        }
        else
        if(inDataType == WildLogDataType.LOCATION) {
            lstWorkspaceEntries = WildLogApp.getApplication().getDBI().listLocations(null, Location.class);
        }
        else
        if(inDataType == WildLogDataType.VISIT) {
            lstWorkspaceEntries = WildLogApp.getApplication().getDBI().listVisits(null, 0, null, false, Visit.class);
        }
        else
        if(inDataType == WildLogDataType.SIGHTING) {
            lstWorkspaceEntries = WildLogApp.getApplication().getDBI().listSightings(0, 0, 0, false, Sighting.class);
        }
        else
        if(inDataType == WildLogDataType.WILDLOG_USER) {
            lstWorkspaceEntries = WildLogApp.getApplication().getDBI().listUsers(null, WildLogUser.class);
        }
        else {
            lstWorkspaceEntries = null;
        }
        WildLogApp.LOGGER.log(Level.INFO, "Sync - " + inDataType.getDescription() + " - Workspace Entries: " + lstWorkspaceEntries.size());
        // UP: Make sure cloud knows about new workspace records
        List<SyncAction> lstSyncActions = new ArrayList<>();
        for (DataObjectWithAudit workspaceEntry : lstWorkspaceEntries) {
            boolean found = false;
            boolean shouldBeSynced = false;
            for (SyncTableEntry cloudEntry : lstCloudEntries) {
                if (workspaceEntry.getID() == cloudEntry.getRecordID()) {
                    found = true;
                    if (workspaceEntry.getAuditTime() > cloudEntry.getData().getAuditTime()) {
                        shouldBeSynced = true;
                    }
                    break;
                }
            }
            if (!found || shouldBeSynced) {
                lstSyncActions.add(new SyncAction("CLOUD_UPLOAD", inDataType, workspaceEntry.getID(), "", workspaceEntry));
            }
        }
        if (!lstSyncActions.isEmpty()) {
            if (rdbModeBatch.isSelected()) {
                List<DataObjectWithAudit> lstRecords = new ArrayList<>(lstSyncActions.size());
                List<Long> lstRecordIDs = new ArrayList<>(lstSyncActions.size());
                    for (SyncAction syncAction : lstSyncActions) {
                        lstRecords.add(syncAction.data);
                        lstRecordIDs.add(syncAction.recordID);
                    }
                logIfFailed(inFeedback, new SyncAction("CLOUD_UPLOAD", inDataType, lstRecords.size(), Arrays.toString(lstRecordIDs.toArray()), null), 
                        UtilsSync.uploadDataBatch(inSyncConnection, inDataType, inWorkspaceID, inDBVersion, lstRecords));
                syncDataUp = syncDataUp + lstRecords.size();
            }
            else {
                for (SyncAction syncAction : lstSyncActions) {
                    logIfFailed(inFeedback, syncAction, UtilsSync.uploadData(inSyncConnection, inDataType, inWorkspaceID, inDBVersion, syncAction.data));
                    syncDataUp++;
                }
            }
        }
        // DOWN: Make sure the workspace knows about new cloud records
        List<Long> lstWorkspaceCreateIDs = new ArrayList<>();
        List<Long> lstWorkspaceUpdateIDs = new ArrayList<>();
        for (SyncTableEntry cloudEntry : lstCloudEntries) {
            boolean found = false;
            boolean shouldBeUpdated = false;
            for (DataObjectWithAudit workspaceEntry : lstWorkspaceEntries) {
                if (workspaceEntry.getID() == cloudEntry.getRecordID()) {
                    found = true;
                    if (workspaceEntry.getAuditTime() < cloudEntry.getData().getAuditTime()) {
                        shouldBeUpdated = true;
                    }
                    break;
                }
            }
            if (!found) {
                lstWorkspaceCreateIDs.add(cloudEntry.getRecordID());
            }
            if (shouldBeUpdated) {
                lstWorkspaceUpdateIDs.add(cloudEntry.getRecordID());
            }
        }
        // For the new or out of sync records, load the full record from the cloud
        List<SyncTableEntry> lstWorkspaceCreateEntries = null;
        List<SyncTableEntry> lstWorkspaceUpdateEntries = null;
        if (rdbModeBatch.isSelected()) {
            if (!lstWorkspaceCreateIDs.isEmpty()) {
                lstWorkspaceCreateEntries = UtilsSync.downloadDataBatch(inSyncConnection, inDataType, inWorkspaceID, 0, lstWorkspaceCreateIDs);
            }
            if (!lstWorkspaceUpdateIDs.isEmpty()) {
                lstWorkspaceUpdateEntries = UtilsSync.downloadDataBatch(inSyncConnection, inDataType, inWorkspaceID, 0, lstWorkspaceUpdateIDs);
            }
        }
        else {
            lstWorkspaceCreateEntries = new ArrayList<>(lstWorkspaceCreateIDs.size());
            for (long recordId : lstWorkspaceCreateIDs) {
                lstWorkspaceCreateEntries.add(UtilsSync.downloadData(inSyncConnection, inDataType, inWorkspaceID, recordId));
            }
            lstWorkspaceUpdateEntries = new ArrayList<>(lstWorkspaceUpdateIDs.size());
            for (long recordId : lstWorkspaceUpdateIDs) {
                lstWorkspaceUpdateEntries.add(UtilsSync.downloadData(inSyncConnection, inDataType, inWorkspaceID, recordId));
            }
        }
        // Check the the downloads were successful
        if (!lstWorkspaceCreateIDs.isEmpty() && (lstWorkspaceCreateEntries == null || lstWorkspaceCreateEntries.size() != lstWorkspaceCreateIDs.size())) {
            logIfFailed(inFeedback, new SyncAction("CLOUD_DOWNLOAD", inDataType, lstWorkspaceCreateIDs.size(), Arrays.toString(lstWorkspaceCreateIDs.toArray()), null), false);
        }
        if (!lstWorkspaceUpdateIDs.isEmpty() && (lstWorkspaceUpdateEntries == null || lstWorkspaceUpdateEntries.size() != lstWorkspaceUpdateIDs.size())) {
            logIfFailed(inFeedback, new SyncAction("CLOUD_DOWNLOAD", inDataType, lstWorkspaceUpdateIDs.size(), Arrays.toString(lstWorkspaceUpdateIDs.toArray()), null), false);
        }
        // Create if not found
        if (lstWorkspaceCreateEntries != null) {
            for (SyncTableEntry cloudEntry : lstWorkspaceCreateEntries) {
                SyncAction syncAction = new SyncAction("WORKSPACE_DOWNLOAD", cloudEntry.getWildLogDataType(), 
                        cloudEntry.getRecordID(), "NEW", cloudEntry.getData());
                if(cloudEntry.getWildLogDataType() == WildLogDataType.ELEMENT) {
                    logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().createElement((ElementCore) syncAction.data, true));
                }
                else
                if(cloudEntry.getWildLogDataType() == WildLogDataType.LOCATION) {
                    logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().createLocation((LocationCore) syncAction.data, true));
                }
                else
                if(cloudEntry.getWildLogDataType() == WildLogDataType.VISIT) {
                    logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().createVisit((VisitCore) syncAction.data, true));
                }
                else
                if(cloudEntry.getWildLogDataType() == WildLogDataType.SIGHTING) {
                    logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().createSighting((SightingCore) syncAction.data, true));
                }
                else
                if(cloudEntry.getWildLogDataType() == WildLogDataType.WILDLOG_USER) {
                    logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().createUser((WildLogUser) syncAction.data, true));
                }
                else {
                    logIfFailed(inFeedback, syncAction, false);
                }
                syncDataDown++;
            }
        }
        // Update if outdated
        if (lstWorkspaceUpdateEntries != null) {
            for (SyncTableEntry cloudEntry : lstWorkspaceUpdateEntries) {
                SyncAction syncAction = new SyncAction("WORKSPACE_DOWNLOAD", cloudEntry.getWildLogDataType(), 
                        cloudEntry.getRecordID(), "UPDATE", cloudEntry.getData());
                if(cloudEntry.getWildLogDataType() == WildLogDataType.ELEMENT) {
                    Element oldElement = WildLogApp.getApplication().getDBI().findElement(syncAction.recordID, null, Element.class);
                    logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().updateElement((ElementCore) syncAction.data, oldElement.getPrimaryName(), true));
                }
                else
                if(cloudEntry.getWildLogDataType() == WildLogDataType.LOCATION) {
                    Location oldLocation = WildLogApp.getApplication().getDBI().findLocation(syncAction.recordID, null, Location.class);
                    logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().updateLocation((LocationCore) syncAction.data, oldLocation.getName(), true));
                }
                else
                if(cloudEntry.getWildLogDataType() == WildLogDataType.VISIT) {
                    Visit oldVisit = WildLogApp.getApplication().getDBI().findVisit(syncAction.recordID, null, false, Visit.class);
                    logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().updateVisit((VisitCore) syncAction.data, oldVisit.getName(), true));
                }
                else
                if(cloudEntry.getWildLogDataType() == WildLogDataType.SIGHTING) {
                    logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().updateSighting((SightingCore) syncAction.data, true));
                }
                else
                if(cloudEntry.getWildLogDataType() == WildLogDataType.WILDLOG_USER) {
                    logIfFailed(inFeedback, syncAction, WildLogApp.getApplication().getDBI().updateUser((WildLogUser) syncAction.data, true));
                }
                else {
                    logIfFailed(inFeedback, syncAction, false);
                }
                syncDataDown++;
            }
        }
    }
    
    private class SyncAction {
        private String command;
        private WildLogDataType type;
        private long recordID;
        private String details;
        private DataObjectWithAudit data;

        private SyncAction(String inCommand, WildLogDataType inType, long inRecordID, String inDetails, DataObjectWithAudit inData) {
            command = inCommand;
            type = inType;
            recordID = inRecordID;
            details = inDetails;
            data = inData;
        }
        
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnConfirm;
    private javax.swing.JButton btnConfirmSyncToken;
    private javax.swing.JComboBox<WildLogThumbnailSizes> cmbThumbnailSize;
    private javax.swing.ButtonGroup grpConflicts;
    private javax.swing.ButtonGroup grpFiles;
    private javax.swing.ButtonGroup grpImages;
    private javax.swing.ButtonGroup grpMode;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator3;
    private javax.swing.JSeparator jSeparator4;
    private javax.swing.JPanel pnlSyncOptions;
    private javax.swing.JPanel pnlSyncToken;
    private javax.swing.JRadioButton rdbImportAllFiles;
    private javax.swing.JRadioButton rdbImportImagesOnly;
    private javax.swing.JRadioButton rdbImportNoFiles;
    private javax.swing.JRadioButton rdbImportOriginalImages;
    private javax.swing.JRadioButton rdbImportThumbnails;
    private javax.swing.JRadioButton rdbModeBatch;
    private javax.swing.JRadioButton rdbModeSingle;
    private javax.swing.JTextArea txaSyncToken;
    // End of variables declaration//GEN-END:variables
}
