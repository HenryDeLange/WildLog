package wildlog.ui.dialogs;

import java.awt.Cursor;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;
import wildlog.WildLogApp;
import wildlog.data.dataobjects.Element;
import wildlog.data.dataobjects.Location;
import wildlog.data.dataobjects.Sighting;
import wildlog.data.dataobjects.Visit;
import wildlog.data.dataobjects.WildLogFile;
import wildlog.data.dataobjects.wrappers.SightingWrapper;
import wildlog.data.dbi.WildLogDBI;
import wildlog.data.dbi.WildLogDBI_h2;
import wildlog.data.enums.WildLogFileType;
import wildlog.data.enums.utils.WildLogThumbnailSizes;
import wildlog.ui.dialogs.utils.UtilsDialog;
import wildlog.ui.helpers.ProgressbarTask;
import wildlog.ui.helpers.cellrenderers.WorkspaceTreeCellRenderer;
import wildlog.ui.helpers.cellrenderers.WorkspaceTreeDataWrapper;
import wildlog.utils.UtilsConcurency;
import wildlog.utils.UtilsFileProcessing;
import wildlog.utils.UtilsImageProcessing;
import wildlog.utils.WildLogPaths;


public class WorkspaceImportDialog extends javax.swing.JDialog {
    private WildLogApp app;
    private Path importWorkspace;
    WildLogDBI importDBI = null;


    public WorkspaceImportDialog(WildLogApp inApp, Path inImportPath) {
        app = inApp;
        importWorkspace = inImportPath;
        try {
        importDBI = new WildLogDBI_h2("jdbc:h2:"
                + (importWorkspace.resolve(WildLogPaths.WILDLOG_DATA.getRelativePath()).resolve(WildLogPaths.DEFAULT_DATABASE_NAME.getRelativePath())).toAbsolutePath()
                + ";AUTOCOMMIT=ON;IGNORECASE=TRUE", false);
        }
        catch (Exception ex) {
            ex.printStackTrace(System.err);
        }
        initComponents();
        // Setup the tree
        treWorkspace.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        treWorkspace.setCellRenderer(new WorkspaceTreeCellRenderer());
        treWorkspace.setToggleClickCount(0);
        // Load the tree
        loadLocationTree();
        // Setup the default behavior
        UtilsDialog.setDialogToCenter(app.getMainFrame(), this);
        UtilsDialog.addEscapeKeyListener(this);
        UtilsDialog.addModalBackgroundPanel(app.getMainFrame(), this);
        // Setup the glasspane on this dialog as well for the JOptionPane's
        UtilsDialog.addModalBackgroundPanel(this, null);
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        grpFiles = new javax.swing.ButtonGroup();
        grpImages = new javax.swing.ButtonGroup();
        grpTreeOrder = new javax.swing.ButtonGroup();
        grpConflicts = new javax.swing.ButtonGroup();
        btnConfirm = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        treWorkspace = new javax.swing.JTree();
        jLabel2 = new javax.swing.JLabel();
        rdbImportAllFiles = new javax.swing.JRadioButton();
        rdbImportImagesOnly = new javax.swing.JRadioButton();
        rdbImportNoFiles = new javax.swing.JRadioButton();
        jSeparator1 = new javax.swing.JSeparator();
        rdbImportOriginalImages = new javax.swing.JRadioButton();
        rdbImportThumbnails = new javax.swing.JRadioButton();
        jLabel1 = new javax.swing.JLabel();
        rdbOrderByLocation = new javax.swing.JRadioButton();
        rdbOrderByElement = new javax.swing.JRadioButton();
        rdbOrderByDate = new javax.swing.JRadioButton();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        txtPrefix = new javax.swing.JTextField();
        rdbKeepWorkspace = new javax.swing.JRadioButton();
        rdbKeepImport = new javax.swing.JRadioButton();
        jSeparator2 = new javax.swing.JSeparator();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Import From An External Workspace");
        setIconImage(new ImageIcon(app.getClass().getResource("resources/icons/WildLog Icon Small.gif")).getImage());
        setMinimumSize(new java.awt.Dimension(720, 650));
        setModal(true);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosed(java.awt.event.WindowEvent evt) {
                formWindowClosed(evt);
            }
        });

        btnConfirm.setIcon(new javax.swing.ImageIcon(getClass().getResource("/wildlog/resources/icons/Update.png"))); // NOI18N
        btnConfirm.setToolTipText("Import the selected records to the active Workspace.");
        btnConfirm.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnConfirm.setFocusPainted(false);
        btnConfirm.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnConfirmActionPerformed(evt);
            }
        });

        javax.swing.tree.DefaultMutableTreeNode treeNode1 = new javax.swing.tree.DefaultMutableTreeNode("root");
        treWorkspace.setModel(new javax.swing.tree.DefaultTreeModel(treeNode1));
        treWorkspace.setFocusable(false);
        treWorkspace.setRequestFocusEnabled(false);
        treWorkspace.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                treWorkspaceMousePressed(evt);
            }
        });
        jScrollPane1.setViewportView(treWorkspace);

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel2.setText("Files:");

        grpFiles.add(rdbImportAllFiles);
        rdbImportAllFiles.setSelected(true);
        rdbImportAllFiles.setText("Import All Files");
        rdbImportAllFiles.setToolTipText("Import all files into the current Workspace.");
        rdbImportAllFiles.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportAllFiles.setFocusPainted(false);
        rdbImportAllFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportAllFilesActionPerformed(evt);
            }
        });

        grpFiles.add(rdbImportImagesOnly);
        rdbImportImagesOnly.setText("Import Images Only");
        rdbImportImagesOnly.setToolTipText("Import only image files into the current Workspace.");
        rdbImportImagesOnly.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportImagesOnly.setFocusPainted(false);
        rdbImportImagesOnly.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportImagesOnlyActionPerformed(evt);
            }
        });

        grpFiles.add(rdbImportNoFiles);
        rdbImportNoFiles.setText("Import No Files");
        rdbImportNoFiles.setToolTipText("Don't import any files into the current Workspace.");
        rdbImportNoFiles.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportNoFiles.setFocusPainted(false);
        rdbImportNoFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbImportNoFilesActionPerformed(evt);
            }
        });

        jSeparator1.setOrientation(javax.swing.SwingConstants.VERTICAL);

        grpImages.add(rdbImportOriginalImages);
        rdbImportOriginalImages.setSelected(true);
        rdbImportOriginalImages.setText("Original Images");
        rdbImportOriginalImages.setToolTipText("Import a copy of the original linked images into the current Workspace.");
        rdbImportOriginalImages.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportOriginalImages.setFocusPainted(false);

        grpImages.add(rdbImportThumbnails);
        rdbImportThumbnails.setText("Thumbnail Images");
        rdbImportThumbnails.setToolTipText("The images that are imported will be reduced in size, the original images will not be imported.");
        rdbImportThumbnails.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbImportThumbnails.setFocusPainted(false);

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel1.setText("Sort Order:");

        grpTreeOrder.add(rdbOrderByLocation);
        rdbOrderByLocation.setSelected(true);
        rdbOrderByLocation.setText("Order by Place");
        rdbOrderByLocation.setToolTipText("Order the tree nodes by Places, then Periods and lastly Creatures.");
        rdbOrderByLocation.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbOrderByLocation.setFocusPainted(false);
        rdbOrderByLocation.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbOrderByLocationActionPerformed(evt);
            }
        });

        grpTreeOrder.add(rdbOrderByElement);
        rdbOrderByElement.setText("Order by Creature");
        rdbOrderByElement.setToolTipText("Order the tree nodes by Creatures, then Places and lastly Periods.");
        rdbOrderByElement.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbOrderByElement.setFocusPainted(false);
        rdbOrderByElement.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbOrderByElementActionPerformed(evt);
            }
        });

        grpTreeOrder.add(rdbOrderByDate);
        rdbOrderByDate.setText("Order by Date");
        rdbOrderByDate.setToolTipText("Order the tree nodes by Year Month Day and then Time.");
        rdbOrderByDate.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbOrderByDate.setEnabled(false);
        rdbOrderByDate.setFocusPainted(false);

        jLabel3.setText("<html><i>The records marked with the WildLog (W) icon will be imported. Hold down the Ctrl key to select only the record, without it's sub-records.</i></html>");

        jLabel4.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel4.setText("Prefix:");

        jLabel5.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel5.setText("Conflicts:");

        txtPrefix.setToolTipText("The imported records' names will be prefixed by the provided text to help prevent any conflicts.");

        grpConflicts.add(rdbKeepWorkspace);
        rdbKeepWorkspace.setSelected(true);
        rdbKeepWorkspace.setText("Keep Active Workspace's Copy");
        rdbKeepWorkspace.setToolTipText("<html>When the active Workspace and the imported Workspace contains records with the same names, <br>then the active Workspace's records will be kept and the imported Workspaces' record will be ignored.</html>");
        rdbKeepWorkspace.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbKeepWorkspace.setFocusPainted(false);

        grpConflicts.add(rdbKeepImport);
        rdbKeepImport.setText("Keep Imported Copy");
        rdbKeepImport.setToolTipText("<html>When the active Workspace and the imported Workspace contains records with the same names, <br>then the imported Workspace's records will be kept and the active Workspaces' record will be overwritten.</html>");
        rdbKeepImport.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        rdbKeepImport.setFocusPainted(false);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane1)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel2)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(rdbImportAllFiles)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(rdbImportImagesOnly)
                                        .addGap(0, 0, 0)
                                        .addComponent(rdbImportNoFiles)
                                        .addGap(2, 2, 2)
                                        .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 5, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(2, 2, 2)
                                        .addComponent(rdbImportOriginalImages)
                                        .addGap(0, 0, 0)
                                        .addComponent(rdbImportThumbnails)
                                        .addGap(0, 0, Short.MAX_VALUE))
                                    .addGroup(layout.createSequentialGroup()
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                            .addComponent(jSeparator2, javax.swing.GroupLayout.Alignment.LEADING)
                                            .addGroup(layout.createSequentialGroup()
                                                .addComponent(jLabel4)
                                                .addGap(5, 5, 5)
                                                .addComponent(txtPrefix, javax.swing.GroupLayout.PREFERRED_SIZE, 139, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                                .addComponent(jLabel5)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                                .addComponent(rdbKeepWorkspace)
                                                .addGap(0, 0, 0)
                                                .addComponent(rdbKeepImport)))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                                .addComponent(btnConfirm, javax.swing.GroupLayout.PREFERRED_SIZE, 110, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(5, 5, 5))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(rdbOrderByLocation)
                                .addGap(0, 0, 0)
                                .addComponent(rdbOrderByElement)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(rdbOrderByDate)))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(btnConfirm, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jSeparator1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(rdbImportOriginalImages)
                                    .addComponent(rdbImportThumbnails)
                                    .addComponent(rdbImportImagesOnly)
                                    .addComponent(rdbImportAllFiles)
                                    .addComponent(rdbImportNoFiles))))
                        .addGap(3, 3, 3)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(rdbKeepWorkspace, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(rdbKeepImport, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addComponent(jLabel4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(txtPrefix, javax.swing.GroupLayout.Alignment.LEADING)))
                        .addGap(4, 4, 4)
                        .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(3, 3, 3)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(rdbOrderByLocation)
                            .addComponent(rdbOrderByElement)
                            .addComponent(rdbOrderByDate))))
                .addGap(2, 2, 2)
                .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(2, 2, 2)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 519, Short.MAX_VALUE)
                .addGap(5, 5, 5))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnConfirmActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnConfirmActionPerformed
        // TODO: Improve error handeling and feedback
        if (txtPrefix.getText() == null || txtPrefix.getText().isEmpty()) {
            int result = UtilsDialog.showDialogBackgroundWrapper(this, new UtilsDialog.DialogWrapper() {
                @Override
                public int showDialog() {
                    return JOptionPane.showConfirmDialog(app.getMainFrame(),
                    "<html>It is highly recommended to provide a unique prefix for the imported data, to help provent conflicts."
                    + "<br/>Are you sure you want to continue?</html>",
                    "WARNING: Importing Without Prefix", JOptionPane.YES_NO_OPTION, JOptionPane.ERROR_MESSAGE);
                }
            });
            if (result != JOptionPane.YES_OPTION) {
                return;
            }
        }
        try {
            if (importWorkspace != null) {
                UtilsConcurency.kickoffProgressbarTask(app, new ProgressbarTask(app) {
                    @Override
                    protected Object doInBackground() throws Exception {
                        app.getMainFrame().getGlassPane().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
                        setProgress(1);
                        setMessage("Starting the Workspace Import");
                        setVisible(false);
                        try {
                            int totalNodes = getNumberOfNodes(treWorkspace.getModel());
                            setProgress(2);
                            setMessage("Workspace Import: " + getProgress() + "%");
                            saveChildren((DefaultMutableTreeNode)treWorkspace.getModel().getRoot(), totalNodes, this, new ProgressCounter());
                            setProgress(100);
                            setMessage("Workspace Import: " + getProgress() + "%");
                        }
                        catch (Exception ex) {
                            throw ex;
                        }
                        finally {
                            app.getMainFrame().refreshHomeTab();
                            dispose();
                            if (importDBI != null) {
                                importDBI.close();
                            }
                        }
                        setProgress(100);
                        setMessage("Done with the Workspace Import");
                        app.getMainFrame().getGlassPane().setCursor(Cursor.getDefaultCursor());
                        return null;
                    }
                });
            }
        }
        catch (Exception ex) {
            ex.printStackTrace(System.err);
            getGlassPane().setVisible(true);
            JOptionPane.showMessageDialog(app.getMainFrame(),
                    "Could not import the Workspace successfully.",
                    "Import Workspace Error", JOptionPane.ERROR_MESSAGE);
            getGlassPane().setVisible(false);
        }
    }//GEN-LAST:event_btnConfirmActionPerformed

    private class ProgressCounter {
        public int counter = 0;
    }

    private int getNumberOfNodes(TreeModel model) {
        return getNumberOfNodes(model, model.getRoot());
    }

    private int getNumberOfNodes(TreeModel model, Object node) {
        int count = 1;
        int nChildren = model.getChildCount(node);
        for (int i = 0; i < nChildren; i++) {
            count += getNumberOfNodes(model, model.getChild(node, i));
        }
        return count;
    }

    private void saveChildren(DefaultMutableTreeNode inNode, int inTotalNodes, ProgressbarTask inProgressbarTask, ProgressCounter inCounter) {
        if (inNode.getUserObject() instanceof WorkspaceTreeDataWrapper) {
            WorkspaceTreeDataWrapper dataWrapper = (WorkspaceTreeDataWrapper) inNode.getUserObject();
            if (dataWrapper.isSelected()) {
                if (dataWrapper.getDataObject()instanceof Location) {
                    Location importLocation = importDBI.find((Location) dataWrapper.getDataObject());
                    String originalWildLogFileID = importLocation.getWildLogFileID();
                    importLocation.setName(txtPrefix.getText() + importLocation.getName());
                    Location workspaceLocation = app.getDBI().find(importLocation);
                    if (workspaceLocation == null) {
                        // New
                        app.getDBI().createOrUpdate(importLocation, null);
                    }
                    else {
                        // Update, only if the option was selected to overwrite the active workspace's entry
                        if (rdbKeepImport.isSelected()) {
                            app.getDBI().createOrUpdate(importLocation, importLocation.getName());
                        }
                        // If the records matching the prefix already exists, then update FileID
                        // (Because the same entry can be in the tree more than once.)
                        originalWildLogFileID = importLocation.getWildLogFileID();
                    }
                    saveFiles(originalWildLogFileID, importLocation.getWildLogFileID());
                }
                else
                if (dataWrapper.getDataObject() instanceof Visit) {
                    Visit importVisit = importDBI.find((Visit) dataWrapper.getDataObject());
                    String originalWildLogFileID = importVisit.getWildLogFileID();
                    importVisit.setName(txtPrefix.getText() + importVisit.getName());
                    importVisit.setLocationName(txtPrefix.getText() + importVisit.getLocationName());
                    Visit workspaceVisit = app.getDBI().find(importVisit);
                    if (workspaceVisit == null) {
                        // New
                        app.getDBI().createOrUpdate(importVisit, null);
                    }
                    else {
                        // Update, only if the option was selected to overwrite the active workspace's entry
                        if (rdbKeepImport.isSelected()) {
                            app.getDBI().createOrUpdate(importVisit, importVisit.getName());
                        }
                        // If the records matching the prefix already exists, then update FileID
                        // (Because the same entry can be in the tree more than once.)
                        originalWildLogFileID = importVisit.getWildLogFileID();
                    }
                    saveFiles(originalWildLogFileID, importVisit.getWildLogFileID());
                }
                else
                if (dataWrapper.getDataObject() instanceof Element) {
                    Element importElement = importDBI.find((Element) dataWrapper.getDataObject());
                    String originalWildLogFileID = importElement.getWildLogFileID();
                    importElement.setPrimaryName(txtPrefix.getText() + importElement.getPrimaryName());
                    Element workspaceElement = app.getDBI().find(importElement);
                    if (workspaceElement == null) {
                        // New
                        app.getDBI().createOrUpdate(importElement, null);
                    }
                    else {
                        // Update, only if the option was selected to overwrite the active workspace's entry
                        if (rdbKeepImport.isSelected()) {
                            app.getDBI().createOrUpdate(importElement, importElement.getPrimaryName());
                        }
                        // If the records matching the prefix already exists, then update FileID
                        // (Because the same entry can be in the tree more than once.)
                        originalWildLogFileID = importElement.getWildLogFileID();
                    }
                    saveFiles(originalWildLogFileID, importElement.getWildLogFileID());
                }
                else
                if (dataWrapper.getDataObject() instanceof SightingWrapper) {
                    Sighting importSighting = importDBI.find(((SightingWrapper) dataWrapper.getDataObject()).getSighting());
                    String originalWildLogFileID = importSighting.getWildLogFileID();
                    importSighting.setLocationName(txtPrefix.getText() + importSighting.getLocationName());
                    importSighting.setVisitName(txtPrefix.getText() + importSighting.getVisitName());
                    importSighting.setElementName(txtPrefix.getText() + importSighting.getElementName());
                    Sighting workpaceSighting = app.getDBI().find(importSighting);
                    if (workpaceSighting == null) {
                        // New
                        // Note: The sighting ID needs to be the same in the new workspace for the linked images to work...
                        app.getDBI().createOrUpdate(importSighting, true);
                    }
                    else {
                        // Update, only if the option was selected to overwrite the active workspace's entry
                        if (rdbKeepImport.isSelected()) {
                            app.getDBI().createOrUpdate(importSighting, false);
                        }
                        else {
                            // Make a new copy of the sighting with a new unique ID.
                            // (Only when a prefix was given, else assume that it is the same sighting.)
                            if (txtPrefix.getText() != null && !txtPrefix.getText().isEmpty()) {
                                importSighting.setSightingCounter(0);
                                app.getDBI().createOrUpdate(importSighting, false);
                            }
                            // No need to worry about the sighting being in the tree more than once...
                        }
                    }
                    saveFiles(originalWildLogFileID, importSighting.getWildLogFileID());
                }
            }
            inProgressbarTask.setTaskProgress(2 + (int)(inCounter.counter/(double)inTotalNodes*97));
            inProgressbarTask.setMessage("Workspace Import: " + inProgressbarTask.getProgress() + "%");
            inCounter.counter++;
        }
        for (int t = 0; t < treWorkspace.getModel().getChildCount(inNode); t++) {
            DefaultMutableTreeNode childNode = (DefaultMutableTreeNode) treWorkspace.getModel().getChild(inNode, t);
            saveChildren(childNode, inTotalNodes, inProgressbarTask, inCounter);
        }
    }

    private void saveFiles(String inExternalWildLogFileID, String inNewInternalWildLogFileID) {
        // Die files se folders word nie rename met die prefix nie. Solank die file nie 'n ander een verkeerdelik overwrite nie maak
        // dit nie saak waar dit op eindig nie. Mens kan die Check and Clean Workspace gebruik om dit na die regte plek skuif te skuif.
        // Maak net seker die file naam is uniek, of overwrite net die bestaande een op die regte tye.
        // Die WildLogFile wat gesave word se FileID en DB path en file naam moet ook dan reg wees.
        // Note: Ek kan WildLogFile.getAbsolutePath() op die import file roep want dit sal relative tot die huidige active workspace wees.
        if (!rdbImportNoFiles.isSelected()) {
            WildLogFile searchExternalWildLogFile = new WildLogFile(inExternalWildLogFileID);
            if (rdbImportImagesOnly.isSelected()) {
                searchExternalWildLogFile.setFileType(WildLogFileType.IMAGE);
            }
            List<WildLogFile> listExternalFiles = importDBI.list(searchExternalWildLogFile);
            for (WildLogFile fileToImport : listExternalFiles) {
                fileToImport.setId(inNewInternalWildLogFileID);
                if (app.getDBI().count(fileToImport) == 0) {
                    // Should be safe to copy the file to a similar folder and add the new WildLogFile using the new FileID in the database.
                    // Copy file
                    UtilsFileProcessing.copyFile(
                            importWorkspace.resolve(fileToImport.getRelativePath()).toAbsolutePath(),
                            fileToImport.getAbsolutePath(), false, true);
                    // Save DB entry
                    app.getDBI().createOrUpdate(fileToImport, false);
                    // Create thumbnails
                    if (WildLogFileType.IMAGE.equals(fileToImport.getFileType())) {
                        fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.VERY_SMALL);
                        fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.SMALL);
                        fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.MEDIUM_SMALL);
                        fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.NORMAL);
                    }
                }
                else {
                    // There is already a file in the current workspace in the same folder as the file to be imported.
                    // If the FileID's are the same and the paths are the same then overwrite it if the radio button was selected.
                    if (rdbKeepImport.isSelected() && inExternalWildLogFileID.equalsIgnoreCase(inNewInternalWildLogFileID)) {
                        UtilsFileProcessing.copyFile(
                                importWorkspace.resolve(fileToImport.getRelativePath()).toAbsolutePath(),
                                fileToImport.getAbsolutePath(), true, true);
                        // No database update needed, since the physical file has been replaced
                        // Delete old thumbnails
                        for (WildLogThumbnailSizes size : WildLogThumbnailSizes.values()) {
                            try {
                                // Note: Ek wil hier net die path kry, nie die thumbnail generate nie (so ek gebruik nie WildLogFile.getAbsoluteThumbnailPath() nie).
                                Files.deleteIfExists(UtilsImageProcessing.calculateAbsoluteThumbnailPath(fileToImport, size));
                            }
                            catch (IOException ex) {
                                ex.printStackTrace(System.err);
                            }
                        }
                        // Create new thumbnails
                        if (WildLogFileType.IMAGE.equals(fileToImport.getFileType())) {
                            fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.VERY_SMALL);
                            fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.SMALL);
                            fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.MEDIUM_SMALL);
                            fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.NORMAL);
                        }
                    }
                    else {
                        // Don't overwrite the file, save a new file and DB record instead if the FileIDs are differnet.
                        if (!inExternalWildLogFileID.equalsIgnoreCase(inNewInternalWildLogFileID)) {
                            // Should be safe to import the file to a similar folder and only update the filename and ID in the database.
                            // Get new filename
                            Path destinationPath = fileToImport.getAbsolutePath();
                            while (Files.exists(destinationPath)) {
                                destinationPath = destinationPath.getParent().toAbsolutePath().resolve("wl_" + destinationPath.getFileName());
                            }
                            // Copy file
                            UtilsFileProcessing.copyFile(
                                    importWorkspace.resolve(fileToImport.getRelativePath()).toAbsolutePath(),
                                    destinationPath, false, true);
                            // Save DB entry
                            fileToImport.setFilename(destinationPath.getFileName().toString());
                            fileToImport.setDBFilePath(Paths.get(fileToImport.getDBFilePath()).getParent().resolve(destinationPath.getFileName()).toString());
                            app.getDBI().createOrUpdate(fileToImport, false);
                            // Create thumbnails
                            if (WildLogFileType.IMAGE.equals(fileToImport.getFileType())) {
                                fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.VERY_SMALL);
                                fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.SMALL);
                                fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.MEDIUM_SMALL);
                                fileToImport.getAbsoluteThumbnailPath(WildLogThumbnailSizes.NORMAL);
                            }
                        }
                        else {
                            // If the IDs are the same and the path is the same and there was no prefix, then assume it's the same file.
                            // Do nothing...
                        }
                    }
                }
            }
        }
    }

    private void rdbImportAllFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportAllFilesActionPerformed
       if (rdbImportAllFiles.isSelected()) {
           rdbImportOriginalImages.setEnabled(true);
           rdbImportThumbnails.setEnabled(true);
       }
    }//GEN-LAST:event_rdbImportAllFilesActionPerformed

    private void rdbImportImagesOnlyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportImagesOnlyActionPerformed
        if (rdbImportImagesOnly.isSelected()) {
           rdbImportOriginalImages.setEnabled(true);
           rdbImportThumbnails.setEnabled(true);
       }
    }//GEN-LAST:event_rdbImportImagesOnlyActionPerformed

    private void rdbImportNoFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbImportNoFilesActionPerformed
        if (rdbImportNoFiles.isSelected()) {
           rdbImportOriginalImages.setEnabled(false);
           rdbImportThumbnails.setEnabled(false);
       }
    }//GEN-LAST:event_rdbImportNoFilesActionPerformed

    private void treWorkspaceMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_treWorkspaceMousePressed
        // Gebruk die muis se posisie om die node te kry want die LastSelected node is verkeerd, vberal as mens die +/- gebruik om te expand/colapse...
        TreePath clickedPath = treWorkspace.getPathForLocation(evt.getX(), evt.getY());
        if (clickedPath != null && clickedPath.getLastPathComponent() != null) {
            if (((DefaultMutableTreeNode) clickedPath.getLastPathComponent()).getUserObject() instanceof WorkspaceTreeDataWrapper) {
                // Get the selected node and change the isSelected property
                WorkspaceTreeDataWrapper dataWrapper = (WorkspaceTreeDataWrapper) ((DefaultMutableTreeNode) clickedPath.getLastPathComponent()).getUserObject();
                dataWrapper.setIsSelected(!dataWrapper.isSelected());
                // Also update all sub nodes
                if (!evt.isControlDown() || !dataWrapper.isSelected()) {
                    selectChildren((DefaultMutableTreeNode) clickedPath.getLastPathComponent());
                }
                if (dataWrapper.isSelected()) {
                    selectParent((DefaultMutableTreeNode) clickedPath.getLastPathComponent());
                }
            }
            // Need to repaint the tree to make sure all icons are refreshed, otherwise Java does the "smart" thing and and caches painted nodes lower down.
            treWorkspace.repaint();
        }
    }//GEN-LAST:event_treWorkspaceMousePressed

    private void selectChildren(DefaultMutableTreeNode inParentNode) {
        for (int t = 0; t < treWorkspace.getModel().getChildCount(inParentNode); t++) {
            DefaultMutableTreeNode childNode = (DefaultMutableTreeNode) treWorkspace.getModel().getChild(inParentNode, t);
            WorkspaceTreeDataWrapper dataWrapper = (WorkspaceTreeDataWrapper) childNode.getUserObject();
            dataWrapper.setIsSelected(((WorkspaceTreeDataWrapper) inParentNode.getUserObject()).isSelected());
            selectChildren(childNode);
        }
    }

    private void selectParent(DefaultMutableTreeNode inNode) {
        if (((DefaultMutableTreeNode) inNode.getParent()).getUserObject() instanceof WorkspaceTreeDataWrapper) {
            ((WorkspaceTreeDataWrapper) ((DefaultMutableTreeNode) inNode.getParent()).getUserObject()).setIsSelected(
                    ((WorkspaceTreeDataWrapper) inNode.getUserObject()).isSelected());
            selectParent((DefaultMutableTreeNode) inNode.getParent());
        }
    }

    private void rdbOrderByLocationActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbOrderByLocationActionPerformed
        if (rdbOrderByLocation.isSelected()) {
            // Load the tree
            loadLocationTree();
        }
    }//GEN-LAST:event_rdbOrderByLocationActionPerformed

    private void rdbOrderByElementActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbOrderByElementActionPerformed
        if (rdbOrderByElement.isSelected()) {
            loadElementTree();
        }
    }//GEN-LAST:event_rdbOrderByElementActionPerformed

    private void formWindowClosed(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosed
        if (importDBI != null) {
            importDBI.close();
        }
    }//GEN-LAST:event_formWindowClosed

    private void loadLocationTree() {
        DefaultMutableTreeNode root = new DefaultMutableTreeNode("WildLog Workspace");
        List<Location> locations = new ArrayList<Location>(importDBI.list(new Location()));
        Map<String, DefaultMutableTreeNode> mapElements;
        Map<String, DefaultMutableTreeNode> mapVisits;
        Collections.sort(locations);
        for (Location location : locations) {
            mapElements = new HashMap<>(500);
            mapVisits = new HashMap<>(500);
            DefaultMutableTreeNode locationNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(location, false));
            root.add(locationNode);
            List<Sighting> sightings = importDBI.list(new Sighting(null, location.getName(), null));
            Collections.sort(sightings, new Comparator<Sighting>() {
                @Override
                public int compare(Sighting sighting1, Sighting sighting2) {
                    int result = sighting1.getVisitName().compareTo(sighting2.getVisitName());
                    if (result == 0) {
                        result = sighting1.getElementName().compareTo(sighting2.getElementName());
                        if (result == 0) {
                            result = sighting1.getDate().compareTo(sighting2.getDate());
                        }
                    }
                    return result;
                }
            });
            for (Sighting sighting : sightings) {
                DefaultMutableTreeNode visitNode = mapVisits.get(sighting.getVisitName());
                if (visitNode == null) {
                    visitNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(new Visit(sighting.getVisitName()), false));
                    mapVisits.put(sighting.getVisitName(), visitNode);
                    // Clear die hashmap hier as 'n nuwe visit gelaai word (die sightings behoort volgens visit gesort te wees, so die visit sal nie weer verskyn nie.
                    mapElements.clear();
                }
                locationNode.add(visitNode);
                DefaultMutableTreeNode elementNode = mapElements.get(sighting.getElementName());
                if (elementNode == null) {
                    elementNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(new Element(sighting.getElementName()), false));
                    mapElements.put(sighting.getElementName(), elementNode);
                }
                visitNode.add(elementNode);
                DefaultMutableTreeNode sightingNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(new SightingWrapper(sighting, true), false));
                elementNode.add(sightingNode);
            }
        }
        treWorkspace.setModel(new DefaultTreeModel(root));
    }

    private void loadElementTree() {
        DefaultMutableTreeNode root = new DefaultMutableTreeNode("WildLog Workspace");
        List<Element> elements = new ArrayList<Element>(importDBI.list(new Element()));
        Map<String, DefaultMutableTreeNode> mapLocations;
        Map<String, DefaultMutableTreeNode> mapVisits;
        Collections.sort(elements);
        for (Element element : elements) {
            mapLocations = new HashMap<>(100);
            mapVisits = new HashMap<>(500);
            DefaultMutableTreeNode elementNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(element, false));
            root.add(elementNode);
            List<Sighting> sightings = importDBI.list(new Sighting(element.getPrimaryName(), null, null));
            Collections.sort(sightings, new Comparator<Sighting>() {
                @Override
                public int compare(Sighting sighting1, Sighting sighting2) {
                    int result = sighting1.getLocationName().compareTo(sighting2.getLocationName());
                    if (result == 0) {
                        result = sighting1.getVisitName().compareTo(sighting2.getVisitName());
                        if (result == 0) {
                            result = sighting1.getDate().compareTo(sighting2.getDate());
                        }
                    }
                    return result;
                }
            });
            for (Sighting sighting : sightings) {
                DefaultMutableTreeNode locationNode = mapLocations.get(sighting.getLocationName());
                if (locationNode == null) {
                    locationNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(new Location(sighting.getLocationName()), false));
                    mapLocations.put(sighting.getLocationName(), locationNode);
                }
                elementNode.add(locationNode);
                DefaultMutableTreeNode visitNode = mapVisits.get(sighting.getVisitName());
                if (visitNode == null) {
                    visitNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(new Visit(sighting.getVisitName()), false));
                    mapVisits.put(sighting.getVisitName(), visitNode);
                }
                locationNode.add(visitNode);
                DefaultMutableTreeNode sightingNode = new DefaultMutableTreeNode(new WorkspaceTreeDataWrapper(new SightingWrapper(sighting, true), false));
                visitNode.add(sightingNode);
            }
        }
        treWorkspace.setModel(new DefaultTreeModel(root));
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnConfirm;
    private javax.swing.ButtonGroup grpConflicts;
    private javax.swing.ButtonGroup grpFiles;
    private javax.swing.ButtonGroup grpImages;
    private javax.swing.ButtonGroup grpTreeOrder;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JRadioButton rdbImportAllFiles;
    private javax.swing.JRadioButton rdbImportImagesOnly;
    private javax.swing.JRadioButton rdbImportNoFiles;
    private javax.swing.JRadioButton rdbImportOriginalImages;
    private javax.swing.JRadioButton rdbImportThumbnails;
    private javax.swing.JRadioButton rdbKeepImport;
    private javax.swing.JRadioButton rdbKeepWorkspace;
    private javax.swing.JRadioButton rdbOrderByDate;
    private javax.swing.JRadioButton rdbOrderByElement;
    private javax.swing.JRadioButton rdbOrderByLocation;
    private javax.swing.JTree treWorkspace;
    private javax.swing.JTextField txtPrefix;
    // End of variables declaration//GEN-END:variables
}
